<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>机器学习</title>
    <url>/2020/06/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫</title>
    <url>/2020/06/12/python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h2><ol>
<li>网络爬虫的尺寸</li>
</ol>
<ul>
<li><p>小规模、数据量小、爬取速度不敏感——Requests库——爬取网页、玩转网页</p>
</li>
<li><p>中规模、数据规模较大、爬取速度敏感——Scrapy库——爬取网站、爬取系列网站 </p>
</li>
<li><p>大规模、搜索引擎、爬取速度关键——定制开发(搜索引擎)——爬取全网</p>
</li>
</ul>
<p>注意：网络爬虫的法律风险：服务器上的数据有产权归属、获取数据后牟利将带来法律风险</p>
<p>​            网络爬虫泄露隐私：</p>
<p>限制网络爬虫：</p>
<ul>
<li>来源审查：判断User-Agent进行限制<ul>
<li>检查来访HTTP协议头的User-Agent域，只响应浏览器或友好爬虫的访问</li>
</ul>
</li>
<li>发布公告：Robots协议</li>
</ul>
<h4 id="Robots协议——网络爬虫排除标准"><a href="#Robots协议——网络爬虫排除标准" class="headerlink" title="Robots协议——网络爬虫排除标准"></a>Robots协议——网络爬虫排除标准</h4><p>网站告知爬虫哪些页面可以抓取，哪些不行</p>
<p>形式：在网站根目录下的robots.txt</p>
<ul>
<li><a href="https://www.jd.com/robots.txt" target="_blank" rel="noopener">https://www.jd.com/robots.txt</a></li>
</ul>
<blockquote>
<p>User-Agent：</p>
<p>disa</p>
</blockquote>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>营养学</title>
    <url>/2020/06/15/%E8%90%A5%E5%85%BB%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="营养学"><a href="#营养学" class="headerlink" title="营养学"></a>营养学</h1><h2 id="营养学基础"><a href="#营养学基础" class="headerlink" title="营养学基础"></a>营养学基础</h2><p>《黄帝内经·素问》“五谷为养、五果为助、五畜为益、五菜为充、气味合而服之、以补精益气。”<em>膳食平衡</em></p>
<h3 id="有用常识"><a href="#有用常识" class="headerlink" title="有用常识"></a>有用常识</h3><ul>
<li>碳水化合物在体内可转化为脂肪</li>
<li>长期食用精制大米而忽略青菜或其他食物的摄入，会导致脚气病，脚气的发生还有就是身体缺乏维生素b1，还有就是代谢因素造成，主要还是由于缺少维生素b1，加之代谢较旺盛</li>
<li>供给能量：蛋白质中含碳、氢、氧元素，当碳水化合物、脂肪提供的能量不能满足机体需要时，蛋白质可被代谢水解，释放能量：1g食物蛋白质在体内产生16.7kj(4kcal)的能量</li>
<li>降血压：降压肽是通过抑制血管紧张素转换酶的活性来实现降压功能的。<strong><em>降压肽大致有三种来源：来自乳酪蛋白的肽类、来自鱼贝类的肽类和来自植物的肽类</em></strong></li>
<li>氨基酸(蛋白质)的吸收是通过小肠粘膜细胞由三种主动运输系统来进行。如果你在膳食中过多地食入某一种氨基酸，竞争作用会使得同类型的其他氨基酸吸收减少—造成食物蛋白质的营养价值下降。</li>
<li>根据对餐后氨基酸、蛋白质代谢快慢的不同，将其分为块膳食蛋白和慢膳食蛋白。例如乳清蛋白就是快膳食蛋白。</li>
<li>肠道中被消化吸收的蛋白质，除了来自于食物外，还有来自于肠道脱落的粘膜细胞和消化液等，每天约有70g。其中大部分可被消化和吸收。</li>
<li>动物性蛋白质质量好、利用率高，但同时富含饱和脂肪酸和胆固醇，而植物性蛋白利用率较低。<em>大豆可提供丰富的优质蛋白质，对人体的益处也越来越被认可，牛奶也是优质蛋白质的重要来源</em></li>
<li>安静状态下空腹的成年人，所需的能量大约25%来自游离脂肪酸，15%来自葡萄糖，其余由内源性脂肪提供</li>
<li>增加饱腹感：食物脂肪由胃进入十二指肠时，可刺激十二指肠产生肠抑胃素，使胃蠕动收到抑制，造成食物由胃进入十二指肠的速度相对缓慢。食物中脂肪含量越高，胃排空的速度越慢，所需时间越长，从而增加饱腹感。</li>
<li></li>
</ul>
<h3 id="膳食宝塔"><a href="#膳食宝塔" class="headerlink" title="膳食宝塔"></a>膳食宝塔</h3><p><img src="/2020/06/15/%E8%90%A5%E5%85%BB%E5%AD%A6/D:%5Cblog%5Csource_posts%5Cimg%5C01.jpeg" alt="01"></p>
<h3 id="营养素"><a href="#营养素" class="headerlink" title="营养素"></a>营养素</h3><ul>
<li>水也是营养素，一旦失去体内水分的10%，生理功能会发生严重紊乱，失去体内水分的20%，人很快就会死亡。体内水温升高或降低都会消耗能量，蒸发1g水可带走2.4kj的热量<em>高温时水分蒸发有助维持体温恒定，蒸桑拿等</em></li>
</ul>
<p>营养素代谢可分为三个阶段</p>
<ol>
<li><p>消化吸收：进入消化道的食物营养素、除水、矿物质、维生素和单糖等小分子物质可被机体直接吸收外，糖类、蛋白质、脂肪及核酸等都须经消化，分解成比较简单的水溶性或脂溶性物质，才能被吸收到体内</p>
</li>
<li><p>中间代谢：食物经消化吸收后，由血液及淋巴液运送到各组织中参加代谢，在许多相互配合的各种酶类催化下，进行分解和合成代谢，细胞内外物质进行交换和能量转变</p>
</li>
<li><p>排泄：物质经过中间代谢过程产生多种终产物，这些终产物再经肾、肠、肝及肺等器官随尿、粪便、胆汁及呼气等排除体外</p>
</li>
</ol>
<ul>
<li><p>蛋白质营养不良：儿童尤为关键</p>
<p>&lt;img src=”<a href="http://i1.fuimg.com/721302/4f5aa9a13160b7a3.png&quot;" target="_blank" rel="noopener">http://i1.fuimg.com/721302/4f5aa9a13160b7a3.png&quot;</a> alt=”Markdown” style=”zoom:80%;” /</p>
</li>
</ul>
<p>对成人而言，蛋白质摄入不足，同样可引起体力下降、水肿、抗病力减弱等症状。</p>
<ul>
<li><p>蛋白质摄入过多</p>
<p>正常情况下，人体不存储蛋白质，所以必须将过多的蛋白质脱氮分离，氮则由尿排出体外。这一过程需要大量水分<em>喝水很关键</em>，从而加重了肾脏的负荷。而且摄入蛋白质过多可能与一些癌症有关。</p>
</li>
</ul>
<h4 id="蛋白质营养状况评价"><a href="#蛋白质营养状况评价" class="headerlink" title="蛋白质营养状况评价"></a>蛋白质营养状况评价</h4><ul>
<li>​    Kwashlorkor-能量满足但蛋白质缺乏，       Marasmus-能量和蛋白质均严重缺乏</li>
</ul>
<p><img src="/2020/06/15/%E8%90%A5%E5%85%BB%E5%AD%A6/D:%5Cblog%5Csource_posts%5Cimg%5C02.png" alt="02"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">例如 我的AMC(大致)=<span class="number">40</span>cm<span class="number">-3.14</span>*<span class="number">4</span>(三头肌部皮褶厚度)cm=大概<span class="number">27</span>cm左右，基本符合标准</span><br></pre></td></tr></table></figure>

<ul>
<li><p>蛋白质的参考摄入量及食物来源</p>
<p>理论上成人每天摄入约30g蛋白质就可满足零氮平衡，但从安全性和消化吸收等其他因素考虑，成人按0.8g/(kg·d)摄入蛋白质为宜。我国由于以植物性食物为主，所以成人蛋白质推荐量为1.16g/(kg·d)。中国营养学会推荐成人蛋白质的RNI为：男性65g/d，女性55g/d。</p>
</li>
</ul>
<h4 id="脂类"><a href="#脂类" class="headerlink" title="脂类"></a>脂类</h4><p>脂类包括脂肪和类脂，是一类化学结构相似或完全不同的有机化合物。总量占人体重的10%~20%。</p>
<ul>
<li>脂肪又称甘油三酯，是体内重要的储能和功能物质，约占体内脂类总量的95%，</li>
<li>类脂主要包括磷脂和固醇类，是细胞膜、机体组织器官、尤其是神经组织的重要组成成分</li>
</ul>
<p><em>安静状态下空腹的成年人，所需的能量大约25%来自游离脂肪酸，15%来自葡萄糖，其余由内源性脂肪提供</em></p>
<ol>
<li><p>机体不能利用脂肪酸分解的含两个碳的化合物合成葡萄糖，所以脂肪不能直接给脑和神经细胞以及血细胞提供能量，因此节食减肥不当可能导致机体分解组织蛋白质，通过糖异生保证血糖水平。</p>
</li>
<li><p>增加饱腹感：食物脂肪由胃进入十二指肠时，可刺激十二指肠产生肠抑胃素，使胃蠕动收到抑制，造成食物由胃进入十二指肠的速度相对缓慢。食物中脂肪含量越高，胃排空的速度越慢，所需时间越长，从而增加饱腹感。</p>
</li>
<li><p>反式脂肪酸主要来源：人造奶油、蛋糕、饼干、油炸食品、乳酪食品及花生酱等，会对人体健康不利，引起冠心病</p>
</li>
<li><p>必须脂肪酸(EFA)</p>
<ul>
<li>人体缺少自身不能合成，必须通过食物供给，</li>
<li>构成磷脂的组成成分，</li>
<li>前列腺素合成的前体：(前列腺素存在于许多器官中，有多种生理功能，如使血管扩张和收缩、神经传导、影响肾脏对水的排泄，奶中的前列腺素可以防止婴儿消化道损伤等)</li>
<li>参与胆固醇代谢：</li>
</ul>
</li>
<li><p>中链脂肪酸：可直接与甘油酯化形成甘油三酯，不需要催化剂，被用来在特殊食品生产(运动员食品)和临床上(治疗高脂蛋白血症、急性和慢性肾功能不全等)</p>
<p>短链脂肪酸：主要来源：食物中膳食纤维、抗性淀粉、低聚糖和糖醇等，</p>
<p>​            主要生理功能：提供机体能量、促进细胞膜脂类物质合成、预防和治疗溃疡性结肠炎、预防结肠肿瘤、对内源性胆固醇的合成有抑制作用</p>
</li>
</ol>
<h5 id="类脂"><a href="#类脂" class="headerlink" title="类脂"></a>类脂</h5><p>包括</p>
<ul>
<li>磷脂：主要有磷酸甘油酯和神经鞘脂，在脑、神经组织和肝脏中含量丰富</li>
<li>胆固醇：主要为胆固醇和植物固醇，</li>
</ul>
<ol>
<li><p>磷脂</p>
<blockquote>
<p>主要功能：</p>
<ol>
<li>提供能量</li>
<li>细胞膜成分</li>
<li>乳化剂作用</li>
<li>改善心血管作用</li>
<li>改善神经系统功能</li>
</ol>
</blockquote>
</li>
<li><p>固醇类</p>
<p>体内胆固醇增多时负反馈肝及其他组织中胆固醇合成限速酶的活性，使胆固醇的合成降低。目前对健康人群胆固醇的摄入不再严格限制，而且适量的胆固醇被认为是人体必需的，可以帮助修复受损的血管壁，(对膳食胆固醇敏感的人群和代谢障碍的人群(糖尿病、高血脂、动脉粥样硬化、冠心病等)，必须强调严格控制膳食胆固醇和饱和脂肪的摄入)。</p>
</li>
</ol>
<h5 id="脂类的消化及其他-营养学评价"><a href="#脂类的消化及其他-营养学评价" class="headerlink" title="脂类的消化及其他(营养学评价)"></a>脂类的消化及其他(营养学评价)</h5><ol>
<li>脂类的消化、吸收及转运</li>
</ol>
<p>机体每天从肠道吸收的甘油三酯约为50<del>100g，磷脂为4</del>8g，其中胆固醇约为300~450mg。</p>
<p>脂肪在胃里的消化有限，主要消化场所是小肠。</p>
<ol start="2">
<li>脂肪的消化率 </li>
</ol>
<p>食物脂肪的消化率与其熔点密切相关。熔点高于50℃的脂肪较难消化，多见于动物脂肪</p>
<h4 id="碳水化合物"><a href="#碳水化合物" class="headerlink" title="碳水化合物"></a>碳水化合物</h4><p>碳水化合物是最早被发现的营养素之一，广泛存在于动植物中，包括构成结构的骨架物质如膳食纤维、果胶、粘多糖和几丁质，以及为能力代谢提供原料的物质如淀粉、糊精和糖原等。</p>
<ol>
<li><p>两大特性—小肠消化和结肠发酵。</p>
<p>小肠消化与血糖和功能有关，发酵与其肠道健康等功能作用有关。</p>
<p>单糖直接在小肠消化吸收，双糖经酶水解后再吸收，多糖水解成葡萄糖后吸收。在小肠不能消化的部分，到结肠经细菌发酵后再吸收。</p>
</li>
</ol>
<ol start="2">
<li><p>分类</p>
<blockquote>
<ol>
<li>单糖   葡萄糖、半乳糖、果糖</li>
</ol>
<p>​     双糖   蔗糖、乳糖、麦芽糖</p>
<p>​     糖醇   山梨糖、甘露糖醇 (糖醇是单糖还原后的产物)</p>
<ol start="2">
<li><p>寡糖</p>
<p>异麦芽低聚寡糖    麦芽糊精</p>
<p>其他寡糖          棉子糖、水苏糖、低聚果糖</p>
</li>
<li><p>多糖</p>
<p>淀粉               直链淀粉、支链淀粉、变性淀粉</p>
<p>非淀粉多糖         纤维素、半纤维素、果胶、亲水胶质物</p>
</li>
</ol>
</blockquote>
</li>
<li><p>益生元——是由不消化的碳水化合物派生出来的，是指不被人体消化系统消化和吸收，能够选择性地促进宿主肠道内原有的一种或几种有益细菌(益生菌)生长繁殖的物质，通过有益菌的繁殖增多，抑制有害细菌生长，从而达到调整肠道菌群，促进机体健康的目的。</p>
</li>
<li><p>食物血糖生成指数(GI)，是反映食物引起人体血糖升高程度的指标，是人体进食后机体血糖生成的应答状况。</p>
<p>GI高的食物，进入胃肠后消化快、吸收完全、葡萄糖迅速进入血液</p>
</li>
</ol>
<h4 id="能量"><a href="#能量" class="headerlink" title="能量"></a>能量</h4><p>人体每日能量消耗主要包括基础代谢、体力活动和食物热效应三方面。</p>
<ul>
<li>机体能量需要量与年龄、性别、生理状态、体重以及身体活动有关；</li>
<li>人体能量摄入量与能量消耗量构成的能量平衡既受到外环境因素如摄食行为、温度变化、体力活动以及精神压力等因素的影响，也受到内环境因素如细胞因子、受体、激素以及神经-体液系统的的影响。</li>
</ul>
<p>营养学领域常使用的能量单位是卡和千卡，1kcal是指在一个标准大气压下，1kg纯水由15℃上升到16℃时所需要的能量。</p>
<ul>
<li>1kj=0.239kcal，1kcal=4.184kj</li>
</ul>
<p>1g 碳水化合物、脂肪和蛋白质在体内氧化时平均产生的能量分别为 4kcal，9kcal 和 4kcal，(吸收率分别为98%，95%，92%，且蛋白质分解产生的含氮化合物尿酸、肌酐等不能被分解利用，排除体外后还释放能量)</p>
<ul>
<li>基础代谢：人体经过10~12小时空腹 和良好的睡眠、清醒仰卧、恒温条件下，无任何身体活动和紧张的思维活动，全身肌肉放松时的能量消耗。(此能量消耗仅用于维持体温、呼吸、心脏搏动、血液循环及其他组织器官和细胞的基本生理功能的需要)</li>
</ul>
<p>基础代谢的影响因素：</p>
<ul>
<li>体型与体质：基础代谢与体表面积的大小呈正比，体表面积越大，向外环境散热越快，基础代谢能量消耗亦越高。机体组织其消耗的能量占基础代谢能量消耗的70%~80%，脂肪组织消耗的能量明显低于瘦体组织；因此，同等体重情况下，瘦高且肌肉发达者的基础代谢能量消耗高于矮胖者，寒冷、大量摄食以及体力过度消耗均可提高基础代谢水平；而禁食、饥饿或少食时，基础代谢能量消耗相应降低。</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>运动健身</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客添加背景音乐</title>
    <url>/2020/06/16/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90/</url>
    <content><![CDATA[<h1 id="如何给博客加上音乐"><a href="#如何给博客加上音乐" class="headerlink" title="如何给博客加上音乐"></a>如何给博客加上音乐</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="博主以身试法推荐一种超easy的方法，也可以用这种方法来下载全网音乐"><a href="#博主以身试法推荐一种超easy的方法，也可以用这种方法来下载全网音乐" class="headerlink" title="博主以身试法推荐一种超easy的方法，也可以用这种方法来下载全网音乐"></a>博主以身试法推荐一种超easy的方法，也可以用这种方法来下载全网音乐</h3><ol>
<li>打开网易云音乐，找到想添加的音乐后，右键点击选择复制链接</li>
</ol>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">https://music.<span class="number">163</span>.com/song?id=<span class="number">428591384</span>&amp;userid=<span class="number">627778085</span></span><br><span class="line">#像这样一个字段，首先是</span><br><span class="line">·音乐来源-网易云音乐，</span><br><span class="line">·类别-歌曲，</span><br><span class="line">·歌曲id-<span class="number">428591384</span>，</span><br><span class="line">·和你自己的用户id</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>得到这个链接后，我们将这个链接中的信息进行加工</li>
</ol>
<p><code>http://link.hhtjim.com/163/428591384.mp3</code>(428591384是刚才链接中的歌曲id)</p>
<ol start="3">
<li><p>复制加工后的链接，粘贴到浏览器中打开即可</p>
<img src="http://i2.tiimg.com/721302/4bd29b318b7a0e93.png" alt="Markdown" style="zoom: 33%;">

</li>
</ol>
<p>然后点击下载，就可以了，所以的音乐都是可以通过这种方式下载的。</p>
<ol start="4">
<li><p>如果你想要往博客中添加背景音乐，也只需要打开主题配置文件_config.yml</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">添加如下代码即可···</span><br><span class="line"><span class="comment"># 默认音乐（随机播放）</span></span><br><span class="line">mp3: </span><br><span class="line">    - http:<span class="regexp">//</span>link.hhtjim.com<span class="regexp">/163/</span><span class="number">428591384</span>.mp3</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="一般的方法"><a href="#一般的方法" class="headerlink" title="一般的方法"></a>一般的方法</h3><p><em>利用网易云提供的音乐 iframe –<code>歌曲外链播放器</code>标签。(但是有的歌曲没有iframe)</em></p>
<p>1.首先打开网易云音乐，搜索你要添加的背景音乐</p>
<img src="http://i2.tiimg.com/721302/cacb2b42c8d0ff7e.png" alt="Markdown" style="zoom:80%;">

<p>2.然后点击生成外链播放器，进去下一个界面</p>
<img src="http://i2.tiimg.com/721302/a9dfd9bd97902740.png" alt="Markdown" style="zoom: 67%;">

<p>3.复制外链播放器的代码</p>
<p>不同的博客主题可能对应的文件不同，例如<code>next主题-- /layout/_macro/sidebar.swig文件</code></p>
<p> <code>yilia主题-- /_partial/left-col.ejs文件</code></p>
<ul>
<li>在对应的文件中添加刚才复制的链接</li>
</ul>
<p>然后重新生成、部署网页即可</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>安装 <code>hexo-tag-aplayer</code></p>
<blockquote>
<p>npm install –save hexo-tag-aplayer </p>
</blockquote>
<p>然后在你需要的地方引入下列字段即可(前后需要用大括号)</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span> aplayer <span class="string">"歌曲名称"</span> <span class="string">"作者"</span> <span class="string">"音乐_url"</span> <span class="string">"封面图片_url"</span> <span class="string">"autoplay"</span> <span class="meta">%</span></span><br></pre></td></tr></table></figure>



<p><code>参数列表</code></p>
<ul>
<li>title : 曲目标题</li>
<li>author: 曲目作者</li>
<li>url: 音乐文件 URL 地址</li>
<li>picture_url: (可选) 音乐对应的图片地址</li>
<li>narrow: （可选）播放器袖珍风格</li>
<li>autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能</li>
<li>width:xxx: (可选) 播放器宽度 (默认: 100%)</li>
<li>lrc:xxx: （可选）歌词文件 URL 地址</li>
</ul>
<h3 id="MetingJS"><a href="#MetingJS" class="headerlink" title="MetingJS"></a>MetingJS</h3><p>同方法二一样，这是 Github推荐的一种更快捷的方法: <code>MetingJS</code></p>
<p>MetingJS 是基于Meting API 的 APlayer 衍生播放器，引入 MetingJS 后，播放器将支持对于 QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放。</p>
<p>如果想在这个插件中使用 MetingJS，需要在 <code>Hexo</code>配置文件<code>_config.yml</code> 中设置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">**复制代码即可**</span></span><br></pre></td></tr></table></figure>

<p>接着就可以通过 (% meting …%) 在文章中使用 MetingJS 播放器了 <code>由于显示问题，输入时需要将括号换成大括号</code></p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 简单示例 (id, server, type)  --&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">meting</span> "60198" "netease" "playlist" %&#125;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 进阶示例 --&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">meting</span> "60198" "netease" "playlist" "autoplay" "mutex:false" "listmaxheight:340px" "preload:none" "theme:#ad7a86"%&#125;</span></span><br><span class="line"><span class="xml">复制代码</span></span><br></pre></td></tr></table></figure>

<p>有关得选项表如下：</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th>默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td><strong>必须值</strong></td>
<td align="left">歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td>
</tr>
<tr>
<td align="left">server</td>
<td><strong>必须值</strong></td>
<td align="left">音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td>
</tr>
<tr>
<td align="left">type</td>
<td><strong>必须值</strong></td>
<td align="left"><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td>
</tr>
<tr>
<td align="left">fixed</td>
<td><code>false</code></td>
<td align="left">开启固定模式</td>
</tr>
<tr>
<td align="left">mini</td>
<td><code>false</code></td>
<td align="left">开启迷你模式</td>
</tr>
<tr>
<td align="left">loop</td>
<td><code>all</code></td>
<td align="left">列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td>
</tr>
<tr>
<td align="left">order</td>
<td><code>list</code></td>
<td align="left">列表播放模式： <code>list</code>, <code>random</code></td>
</tr>
<tr>
<td align="left">volume</td>
<td>0.7</td>
<td align="left">播放器音量</td>
</tr>
<tr>
<td align="left">lrctype</td>
<td>0</td>
<td align="left">歌词格式类型</td>
</tr>
<tr>
<td align="left">listfolded</td>
<td><code>false</code></td>
<td align="left">指定音乐播放列表是否折叠</td>
</tr>
<tr>
<td align="left">storagename</td>
<td><code>metingjs</code></td>
<td align="left">LocalStorage 中存储播放器设定的键名</td>
</tr>
<tr>
<td align="left">autoplay</td>
<td><code>true</code></td>
<td align="left">自动播放，移动端浏览器暂时不支持此功能</td>
</tr>
<tr>
<td align="left">mutex</td>
<td><code>true</code></td>
<td align="left">该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td>
</tr>
<tr>
<td align="left">listmaxheight</td>
<td><code>340px</code></td>
<td align="left">播放列表的最大长度</td>
</tr>
<tr>
<td align="left">preload</td>
<td><code>auto</code></td>
<td align="left">音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td>
</tr>
<tr>
<td align="left">theme</td>
<td><code>#ad7a86</code></td>
<td align="left">播放器风格色彩设置</td>
</tr>
</tbody></table>
<h4 id="附-外链转换工具"><a href="#附-外链转换工具" class="headerlink" title="附:外链转换工具"></a>附:外链转换工具</h4><img src="http://i2.tiimg.com/721302/8d42ffd3d82cc61a.png" alt="Markdown" style="zoom:80%;">]]></content>
      <categories>
        <category>全网音乐(转外链播放)</category>
      </categories>
      <tags>
        <tag>博客个性化</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">title: 数据结构</span><br><span class="line">date: 2020<span class="string">-06</span><span class="string">-26</span> 08:00:30</span><br><span class="line"><span class="keyword">tags:</span> </span><br><span class="line">- 数据结构</span><br><span class="line">categories:</span><br><span class="line">- 基础</span><br></pre></td></tr></table></figure>



<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>数据结构在学什么？</p>
<ul>
<li><p>如何用程序代码把现实世界的问题信息化</p>
</li>
<li><p>如何用计算机高效地处理这些信息从而创造价值</p>
</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">上：   C、数据结构<span class="comment">(软件)</span></span><br><span class="line">        操作系统             通过计算机网络    互联互通</span><br><span class="line">下：    计组<span class="comment">(硬件)</span></span><br></pre></td></tr></table></figure>

<h3 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h3><ul>
<li><p>数据</p>
</li>
<li><p>数据元素、数据项</p>
</li>
<li><p>数据对象、数据结构</p>
</li>
<li><p>数据类型、抽象数据类型</p>
<p>数据类型：是一个值的集合和定义在此集合上的一组操作的总称</p>
<p>​         例：bool类型： true和false ，操作：与或非</p>
<p>抽象数据类型：用数学化语言定义数据和逻辑结构、定义运算、与具体存储结构无关。</p>
</li>
</ul>
<h3 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h3><ul>
<li><p>逻辑结构：线性-树形-图结构</p>
</li>
<li><p>存储(物理)结构：顺序存储-链式-索引-散列存储(哈希)</p>
</li>
<li><p>数据的运算：运算的定义是针对逻辑结构的，运算的实习是针对存储结构的</p>
</li>
</ul>
<p>在讨论一种数据结构时：</p>
<ol>
<li>定义逻辑结构(数据元素之间的关系)</li>
<li>定义数据运算</li>
<li>确定存储结构，实现数据结构</li>
</ol>
<p>程序=数据结构+算法</p>
<p>算法：有穷性、确定性、可行性、输入、输出</p>
<p>好算法：算法执行省时、省内存</p>
<p>​                时间复杂度低、空间复杂度低</p>
<p>算法时间复杂度</p>
<p><em>事前预估算法时间开销T与问题规模n的关系</em></p>
<p>T1(n)=O(n)<strong>大O表示同阶，同等数量级</strong></p>
<p>且在计算时间复杂度时：多项相加，只保留最高阶的项，且系数变为1</p>
<p>​                                           多项相乘，都保留</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">O(1)</span>&lt;<span class="constructor">O(<span class="params">log2</span> <span class="params">n</span>)</span>&lt;<span class="constructor">O(<span class="params">n</span>)</span>&lt;<span class="constructor">O(<span class="params">nlog2</span> <span class="params">n</span>)</span>&lt;<span class="constructor">O(<span class="params">n</span>²)</span>&lt;<span class="constructor">O(<span class="params">n</span>³)</span>&lt;<span class="constructor">O(2的<span class="params">n</span>次方)</span>&lt;<span class="constructor">O(<span class="params">n</span>!)</span>&lt;<span class="constructor">O(<span class="params">n</span>的<span class="params">n</span>次方)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>顺序执行的代码忽略常数项</li>
<li>只考虑循环中的执行次数与n的关系</li>
</ul>
<p>空间复杂度</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">普通程序：找到所占空间大小与问题规模相关的变量，然后分析之间关系<span class="variable">x</span>=<span class="function"><span class="title">f</span>(<span class="variable">n</span>)，</span></span><br><span class="line"><span class="function">即算法空间复杂度=<span class="variable">x</span>的数量级<span class="title">O</span>(<span class="variable">x</span>)</span></span><br><span class="line">递归程序：递归调用的深度<span class="variable">x</span>=问题规模<span class="function"><span class="title">f</span>(<span class="variable">n</span>)，<span class="variable">x</span>的数量级<span class="title">O</span>(<span class="title">f</span>(<span class="variable">n</span>))就是算法空间复杂度</span></span><br><span class="line"><span class="function">计算： 加法规则：取复杂度最大</span></span><br><span class="line"><span class="function">     乘法规则：相乘</span></span><br></pre></td></tr></table></figure>

<h2 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h2><h3 id="线性表的定义和基本操作"><a href="#线性表的定义和基本操作" class="headerlink" title="线性表的定义和基本操作"></a>线性表的定义和基本操作</h3><p>线性表也是一种逻辑结构，表示元素之间一对一相邻的关系</p>
<p>​            是具有<em>相同类型</em>的n个元素的<strong>有限序列</strong>，n为表长、当n=0时为空表</p>
<p>特点：个数有限、排序有先后次序、数据类型都相同</p>
<p><em>基本操作</em></p>
<ul>
<li>InitList(&amp;L)：初始化表，</li>
<li>DestroyList(&amp;L)销毁操作</li>
<li>LocateElem(L,e):按值查找</li>
<li>GetElem(L,i):按位查找</li>
<li>ListInsert(&amp;L,i,e):插入操作，前插</li>
<li>ListDelete(&amp;L,i,&amp;e):删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值</li>
<li>PrintList(L)：输出操作</li>
<li>Empty(L)：判空操作，若L为空表，则返回TRUE，否则返回FALSE</li>
<li>Length(L):求表长</li>
</ul>
<h3 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h3><p>顺序表</p>
<p>逻辑上相邻的元素，内存中位置也相邻<em>(地址=基址+变址)</em></p>
<p>顺序表定义</p>
<ul>
<li><p>数组静态分配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50         #定义数组最大容量</span><br><span class="line">typedef struct&#123;           #结构体</span><br><span class="line">   ElemType data[MaxSize];   #ElemType类型的数组</span><br><span class="line">   int length            #顺序表的长度</span><br><span class="line">&#125;SqList;                #SqList代表该结构体的名字</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>数组动态分配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50        </span><br><span class="line">typedef struct&#123;           </span><br><span class="line">   ElemType *data;        #用指针定义第一个单元地址  </span><br><span class="line">   int length            </span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><em>动态分配语句：</em> C ：L.data=(Elemtype*<em>)malloc(sizeof(ElemType)</em>乘InitSize)_</p>
<p>​                                  Elemtype*  ：强制类型转换，后边分配地址</p>
<h4 id="基本操作："><a href="#基本操作：" class="headerlink" title="基本操作："></a>基本操作：</h4><ul>
<li>插入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool ListInsert(SqList  &amp;L,  int  i,ElemType   e)&#123; </span><br><span class="line">    # i 是顺序表的标号，不是数组下标</span><br><span class="line">      if(i&lt;1 ||i&gt;L.length+1)</span><br><span class="line">              return false;</span><br><span class="line">      if(L.length&gt;&#x3D;MaxSize)</span><br><span class="line">              return  false;</span><br><span class="line">     for(int j&#x3D;L.length ;  j&gt;&#x3D;i ;   j--)</span><br><span class="line">              L.data[j]&#x3D;L.data[i-1];</span><br><span class="line">      L.data[i-1]&#x3D;e;</span><br><span class="line">      L.length++; </span><br><span class="line">      return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">** L.data[i-1]&#x3D;e;      i-1是数组下标对应顺序表第i个元素</span><br></pre></td></tr></table></figure>

<ul>
<li>删除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool ListDelete(SqList  &amp;L,  int  i,ElemType e)&#123;</span><br><span class="line">  if(i&lt;1||i&gt;L.length)</span><br><span class="line">    return false;</span><br><span class="line">  e&#x3D;L.data[i-1];</span><br><span class="line">  for(int j&#x3D;1; j&lt;L.length; j++)</span><br><span class="line">    L.data[j-1]&#x3D;L.data[j];</span><br><span class="line">  L.length--;</span><br><span class="line">  return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>按值查找</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">         <span class="keyword">if</span>(L.data[i]==e)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;  #当找到值对应的顺序表的位置时，</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;          #返回的是它的顺序表标号    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h3><p>单链表</p>
<p>通过一组任意的存储单元来存储线性表中的数据元素</p>
<p>不仅存储数据本身，还存储下一个数据的地址</p>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure>

<p><em>判断单链表L为空</em></p>
<ol>
<li>不带，head == null时，</li>
<li>带有头结点，head -&gt;next为null时，</li>
</ol>
<h4 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h4><ol>
<li>头插法(直接插入元素)</li>
</ol>
<p><em>s.next=L.next<br>L.next=s</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LinkList List_HeadInsert (LinkList  &amp;L)&#123;</span><br><span class="line">    LNode  *s; int  x;</span><br><span class="line">    L-&gt;next&#x3D;NULL;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    while(x!&#x3D;9999)&#123;</span><br><span class="line">        s&#x3D;(LNode*)malloc(sizeof(LNode));</span><br><span class="line">        s-&gt;data&#x3D;x;</span><br><span class="line">        s-&gt;next&#x3D;L-&gt;next;</span><br><span class="line">        L-&gt;next&#x3D;s;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>尾插法(直接插入元素)</li>
</ol>
<p><em>r-&gt;next=s</em></p>
<p><em>r=s</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LinkList List_HeadInsert (LinkList  &amp;L)&#123;</span><br><span class="line">    int  x;</span><br><span class="line">    L&#x3D;(LinkList)malloc(sizeof(LNode));</span><br><span class="line">    LNode *s,*r &#x3D;L;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    while(x!&#x3D;9999)&#123;</span><br><span class="line">        s&#x3D;(LNode*)malloc(sizeof(LNode));</span><br><span class="line">        s-&gt;data&#x3D;x;</span><br><span class="line">        r-&gt;next&#x3D;s;</span><br><span class="line">        r&#x3D;s;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next&#x3D;NULL;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>按序号查找&amp;按值查找</p>
<p>都要遍历单链表</p>
</li>
</ol>
<ol start="4">
<li>插入节点</li>
</ol>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">p=GetElem(L.i<span class="number">-1</span>);   通过查找到第i个节点的位置</span><br><span class="line">s-&gt;<span class="keyword">next</span>=p-&gt;<span class="keyword">next</span>;</span><br><span class="line">p-&gt;<span class="keyword">next</span>=s;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>删除</li>
</ol>
<p><strong>p=GetElem(L,i-1);</strong></p>
<p><strong>q=p-&gt;next;</strong></p>
<p><strong>p-&gt;next=q-&gt;next;</strong></p>
<p><strong>free(q);</strong></p>
<p>(2) 删除给点节点(数据交换)</p>
<p><em>q=p-&gt;next;</em></p>
<p><em>p-&gt;data=p-&gt;next-&gt;data;</em></p>
<p><em>p-&gt;next=q-&gt;next;</em></p>
<p><em>free(q);</em></p>
<ol start="6">
<li>求表长</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int count&#x3D;0;</span><br><span class="line"></span><br><span class="line">while(p-&gt;next!&#x3D;NULL)&#123;</span><br><span class="line"></span><br><span class="line">cout++;</span><br><span class="line"></span><br><span class="line">p&#x3D;p-&gt;next;&#125;</span><br></pre></td></tr></table></figure>

<p>注：<em>引入头结点，能够统一空表和非空表的判断</em></p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">      ElemType data;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>  *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode, *DLinkList;</span><br></pre></td></tr></table></figure>

<p>循环链表：循环单链表、循环双链表</p>
<p>静态链表：数组实现</p>
<h3 id="顺序表与链表的比较"><a href="#顺序表与链表的比较" class="headerlink" title="顺序表与链表的比较"></a>顺序表与链表的比较</h3><ol>
<li><p>存取方式</p>
<p>顺序表 可以实现顺序存取和随机存取</p>
<p>单链表 只能实现顺序存取</p>
</li>
<li><p>逻辑结构和物理地址</p>
<p>顺序表 逻辑相邻物理上也相邻，通过相邻表示逻辑关系</p>
<p>单链表 逻辑相邻物理上不一定相邻，通过指针表示逻辑关系</p>
</li>
<li><p>基本操作</p>
</li>
<li><p>内存空间</p>
<p>顺序存储 无论静态分配还是非静态都需要预先分配合适的内存空间</p>
<p>​      静态分配：太大浪费、太小溢出</p>
<p>​      动态分配： 扩充时需要大量移动元素、操作效率低</p>
<p>链式存储 在需要时分配结点空间即可，高效方便，但指针要使用额外空间</p>
</li>
</ol>
<p>怎样选择线性表的存储结构？</p>
<p>当存储规模难估计 ——  单链表</p>
<p>存储密度大             ——  顺序表按序号</p>
<p>按序号访问时         ——  顺序表 </p>
<p>插入和删除             —— 单链表 </p>
<p>基于数组                 —— 顺序表</p>
<p>基于指针                 —— 单链表</p>
<p><em>3个常用操作</em></p>
<ul>
<li><p>最值</p>
<p>顺序表：遍历，  链表：用两个指针来移动比较</p>
</li>
<li><p>转置</p>
<p>顺序表：用两个指针，一个头、一个尾互相交换值，当i=j,或者i&gt;j时结束</p>
<p>链表</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;<span class="keyword">next</span>!=r)&#123;</span><br><span class="line">temp= p-&gt;<span class="keyword">next</span>;</span><br><span class="line">p-&gt;<span class="keyword">next</span>= temp-&gt;<span class="keyword">next</span>;</span><br><span class="line">temp-&gt;<span class="keyword">next</span>=r-&gt;<span class="keyword">next</span>;</span><br><span class="line">r-&gt;<span class="keyword">next</span>=temp;</span><br><span class="line">&#125;                           <span class="comment">#O(n)</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>合并</p>
<p>线性表</p>
</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">int i=0,j=0;</span><br><span class="line">int k=0;</span><br><span class="line">for(;i&lt;L1.Size&amp;&amp;j&lt;L2.Size;k++)&#123;</span><br><span class="line">  if(L1<span class="comment">[i]</span>&lt;L2<span class="comment">[j]</span>)</span><br><span class="line">   L<span class="comment">[k]</span>=L1<span class="comment">[i++]</span>;</span><br><span class="line">  else</span><br><span class="line">  L<span class="comment">[k]</span>=L2<span class="comment">[j++]</span>;</span><br><span class="line">&#125;</span><br><span class="line">while(i&lt;L1.Size)</span><br><span class="line">L<span class="comment">[k++]</span>=L1<span class="comment">[i++]</span>;</span><br><span class="line">while(j&lt;L2.Size)</span><br><span class="line">L<span class="comment">[k++]</span>=L1<span class="comment">[i++]</span>;                 #O(n)</span><br></pre></td></tr></table></figure>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol>
<li>基本概念(后进先出LIFO)</li>
</ol>
<p>只允许在一端进行插入或删除操作的线性表(栈顶TOP、栈底bottom)</p>
<ol start="2">
<li><p>基本操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InitStack(&amp;S):  初始化一个空栈S</span><br><span class="line">StackEmpty(S):  判断一个栈是否为空，为空---true，否则返回false</span><br><span class="line">Push(&amp;S,&amp;x):   进栈，若栈S未满，则加入x</span><br><span class="line">Pop(&amp;S,&amp;x):    出栈，若栈S非空，则弹出栈顶元素，用x返回</span><br><span class="line">GetTop(S,&amp;x):   读栈顶元素，非空，则返回栈顶元素</span><br><span class="line">ClearStack(&amp;S):  销毁栈，并释放S占用的内存空间</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>栈的顺序存储</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   ElemType data[MaxSize];</span><br><span class="line">   <span class="keyword">int</span> top;            #标识变量top  指向数组尾部的指针</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<ul>
<li>栈空条件   S.top == -1;</li>
<li>栈长       S.top+1;</li>
<li>栈满       S.top==MaxSize-1;</li>
</ul>
<p>（2）共享栈</p>
</li>
</ol>
<p>将两个栈底设置在共享空间的两端，栈顶向空间中间延伸</p>
<p>判空：  0号栈top ==-1</p>
<p>​              1号栈top == MaxSize</p>
<p>栈满：top1-top0==1</p>
<ol start="4">
<li><p>栈的链式存储</p>
<p>所有操作都在表头进行</p>
</li>
</ol>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ol>
<li><p>基本概念(先进先出)</p>
<p>只允许在表的一端进行插入，表的另一端进行删除操作的线性表</p>
</li>
<li><p>基本操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InitQueue(&amp;Q): 初始化队列，构造一个空队列Q</span><br><span class="line">QueueEmpty(Q): 判队列空，若队列Q为空返回true，否则返回false</span><br><span class="line">EnQueue(&amp;Q,x): 入队，若队列Q未满，则将x加入使之成为新的队尾</span><br><span class="line">DeQueue(&amp;Q,&amp;x):出队，若队列Q非空，则删除队头元素，并用x返回</span><br><span class="line">GetHead(Q,&amp;x): 读对头元素，若队列Q非空则用x返回对头元素</span><br><span class="line">ClearQueue(&amp;Q):销毁队列，并释放队列Q占用的内存空间</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储结构实现队列</p>
<p>front指针(队首)—– 出队</p>
<p>rear指针(队尾) —– 入队   </p>
<p>初始化时： front==rear==0</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>队空条件 Q.front==Q.rear （为什么不等于0—当插入一个元素并删除后，两个指针都发生移动，但值不为0）</p>
</li>
<li><p>队长     Q.rear-Q.front</p>
</li>
<li><p>队满    (容易假溢出，我们根据Q.rear=Maxsize来判断，但是当队列有进行过删除操作时，队头有空不满)</p>
<p>所以就有了—</p>
</li>
</ul>
<p>  循环队列</p>
<p>  把存储队列的顺序队列在逻辑上视为一个环</p>
<p>  ​     实现：</p>
<pre><code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">front指针移动：</span><br><span class="line">Q.front = (Q.front+<span class="number">1</span>) % MaxSize</span><br><span class="line">rear指针移动：</span><br><span class="line">Q.rear = (Q.rear+<span class="number">1</span>) % MaxSize</span><br><span class="line">队列长度：</span><br><span class="line">(Q.rear+MaxSize-Q.front) % MaxSize</span><br></pre></td></tr></table></figure></code></pre><p>  判断队空和队满：</p>
<ul>
<li>方法一：牺牲一个存储单元</li>
<li>方法二：增加一个变量代表元素的个数</li>
<li>方法三：增加tag标识(当进队时，tag=1，出队时，tag=0)</li>
</ul>
<ol start="4">
<li><p>队列的链式存储</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<p>判空： Q.front=Q.rear</p>
<p>入队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ENQueue</span><span class="params">(LinkQueue &amp;Q,ElemTyep x)</span></span>&#123;</span><br><span class="line"> LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line"> s-&gt;data = x;</span><br><span class="line"> s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"> Q.rear-&gt;next = s;</span><br><span class="line"> Q.rear = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合法出栈序列：</p>
<p>只要有大的出，剩下比它小的没出的，都要递减出</p>
<ol start="5">
<li>允许在两端都可以进行插入和删除操作的队列</li>
</ol>
<h3 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h3></li>
<li><p>括号匹配</p>
<ul>
<li>一个空栈，顺序读括号</li>
<li>若是右括号，则与栈顶元素进行匹配，匹配则弹出，不匹配则该序列不合法</li>
<li>若是左括号，则压入栈中</li>
<li>若全部元素遍历完毕，栈中非空则序列不合法</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>表达式求值</p>
<p>前缀、中缀、后缀表达式</p>
<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C1.png" alt="1"></p>
</li>
<li><p>递归</p>
</li>
</ol>
<ul>
<li>数组</li>
</ul>
<p>数组是线性表的推广，数组一旦被定义，其维度和维界不可变</p>
<ol>
<li><p>存储结构</p>
<p>行优先、列优先</p>
</li>
</ol>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>压缩存储：你指多个值相同的元素只分配一个存储空间，对零元素不分配存储空间</p>
<p>特殊矩阵：  指具有许多相同矩阵元素或零元素，且这些元素分布有一定规律性</p>
<p><em>特殊矩阵的压缩存储</em>： 找出特殊矩阵中值相同的矩阵元素的分布规律， 把那些呈现规律性分布、值相同的多个矩阵元素压缩存储到一个存储空间上</p>
<ol>
<li>对称矩阵  a-i，j  = a-j，i</li>
</ol>
<p>​         存放数组 B[n(n+1)]/2</p>
<ul>
<li>按行存放：  数组下标 k=1+2+…+(i-1)+j-1+1-1</li>
<li>​              当i&gt;=j   k=i(i-1)/2+j-1  下三角部分</li>
<li>​              当i&lt;j   k=j(j-1)/2+i-1   上三角部分</li>
</ul>
<p>​                                   </p>
<ol start="2">
<li><p>三角矩阵</p>
<p>下三角矩阵：   上三角去元素为同一常量</p>
<p>上三角矩阵：   下三角去元素为同一常量</p>
</li>
<li><p>三对角矩阵</p>
<p>对角线两侧有元素，相当于1条主对角线+附近两条类似对角线</p>
<p>数组下标 k = 3*(i-1)-1+j-i+1+1-1</p>
<p>​            = 2i+j-3</p>
</li>
<li><p>稀疏矩阵：矩阵中非零元素的个数t来说非常多，且分布不规律</p>
<p> 三元组(行标、列表、值)</p>
<p> i   j   value</p>
<p> 0   0     1</p>
</li>
</ol>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><ol>
<li><p>定义：由零个或多个字符组成的有限序列(串中空格也是特殊字符)    </p>
<p>串中任意个连续的字符组成的子序列称为该串的子串，包含子串的串为主串</p>
</li>
<li><p>存储结构</p>
</li>
</ol>
<ul>
<li><p>定长顺序存储:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> ch[MAXLEN];</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆分配存储表示：   malloc()/free() </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> *ch;</span><br><span class="line">   <span class="keyword">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>
</li>
<li><p>块链存储表示：</p>
<p>每一个单链表就是一个块链</p>
</li>
</ul>
<ol start="3">
<li><p>基本操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StrAssign(&amp;T,chars):赋值操作</span><br><span class="line">SriCompare(S,T):比较操作，若S&gt;T，则返回值&gt;0;若S&#x3D;T,则返回值&#x3D;0；若S&lt;T，则返回值&lt;0;</span><br><span class="line">StrLength(S):求串长，返回串S的元素个数</span><br><span class="line">SubString(&amp;Sub, S , pos, len):求子串，用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">Concat(&amp;T, S1, S2):串联接，用T返回由S1和S2联接而成的新串。</span><br><span class="line">Index(S,T,pos):定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第pos个字符后第一次出现的位置；否则函数值为0；</span><br><span class="line">SrtCopy(S):复制操作，由串S复制得到串T</span><br><span class="line">StrEmpty(S):判空操作，若S为空串，返回TRUE，若非空，返回FALSE</span><br><span class="line">Replace(&amp;S, T, V): 替换子串，用V替换主串Szhong出现的所有与T相等的不重叠的子串</span><br><span class="line">StrInsert(&amp;S, pos, len): 删除子串，从串S中删除第pos个字符起长度为len的子串</span><br><span class="line">ClearString(&amp;S): 清空操作，将S请为空串</span><br><span class="line">DestroyString(&amp;S)；销毁串</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="串-模式匹配"><a href="#串-模式匹配" class="headerlink" title="串 模式匹配"></a>串 模式匹配</h3><ol>
<li><p>SubString(&amp;Sub, S , pos, len) 找子串</p>
<p>SriCompare(S,T):比较子串</p>
</li>
<li><p>模式匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Index(SString S, SString T, int pos)&#123;</span><br><span class="line">  int i&#x3D;pos, j&#x3D;1;</span><br><span class="line">  while(i&lt;&#x3D;S.length &amp;&amp; j&lt;&#x3D;T.length)&#123;</span><br><span class="line">  if(S.ch[i]&#x3D;&#x3D;T.ch[j])&#123;</span><br><span class="line">     i++;</span><br><span class="line">     j++;       #  当第一个字符匹配成功时，继续往后匹配剩下的子串</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">      i&#x3D;i-j+2;   #主串的位置往后移动匹配子串</span><br><span class="line">      j&#x3D;1;      # 子串位置不变</span><br><span class="line">  &#125;</span><br><span class="line">  if(j&gt;T.length)</span><br><span class="line">     return i-T.length;</span><br><span class="line">  else </span><br><span class="line">     return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>和模式匹配一样，重要在于，匹配失败后，跳转到第几个字符</p>
<p>next数组：记录这个前缀和后缀的公共串，方便匹配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">模式串      next[]</span><br><span class="line"> b         next[<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line"> b a        next[<span class="number">2</span>]=<span class="number">0</span></span><br><span class="line"> b a c       next[<span class="number">3</span>]=<span class="number">0</span></span><br><span class="line"> b a c b      next[<span class="number">4</span>]=<span class="number">1</span></span><br><span class="line"> b a c b a     next[<span class="number">5</span>]=<span class="number">2</span></span><br><span class="line"> b a c b a b    next[<span class="number">6</span>]=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>移动序列：  Move = (j-1) - next[j-1]</p>
<p>KMP算法</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void get_next(String T, int net[])&#123;</span><br><span class="line">  int i&#x3D;1, j&#x3D;0;</span><br><span class="line">  next[1]&#x3D;0;</span><br><span class="line">  while(i&lt;T.length)&#123;</span><br><span class="line">    if(j&#x3D;&#x3D;0||T.ch[i]&#x3D;&#x3D;T.ch[j])&#123;</span><br><span class="line">    ++i; ++j;next[i]&#x3D;j;</span><br><span class="line">    &#125;else</span><br><span class="line">       j&#x3D;next[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Index_KMP(String S, String T, int next[], int pos)&#123;</span><br><span class="line">    int i&#x3D;pos, j&#x3D;1;</span><br><span class="line">    while(i&lt;&#x3D;S.length &amp;&amp; j&lt;&#x3D;T.length)&#123;</span><br><span class="line">        if(j&#x3D;&#x3D;0||S.ch[i]&#x3D;&#x3D;T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            j&#x3D;next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    if(j&gt;T.length)</span><br><span class="line">        return i-T.length;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C2.png" alt="2"></p>
<ol>
<li>基本概念</li>
</ol>
<p>树是n个结点的有限集合，n=0时，称为空树</p>
<p>n个结点的树中，只有n-1条边</p>
<p>祖先结点、子孙结点、双亲、孩子结点、兄弟结点</p>
<p>结点的度：树种一个结点的子结点的个数称为该结点的度</p>
<p>树的度：树中所有结点的最大值</p>
<p>度大于0的结点称为分支结点</p>
<p>度为0的结点称为叶子结点</p>
<ul>
<li>结点的层次 从根结点以此 第一层···</li>
<li>结点的高度 经历的层次从底到根</li>
<li>结点的深度 反过来 从根到底经历的层次</li>
</ul>
<p>树的高度(深度)为最大高度</p>
<ul>
<li><p>无序树、有序树</p>
</li>
<li><p>路径 一定是自上而下的，树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的</p>
</li>
</ul>
<p>​       路径长度：路径上经过的边的个数</p>
<ul>
<li>森林： m(M&gt;=0)棵互不相见的树的集合</li>
</ul>
<ol start="2">
<li>树的性质<ul>
<li>树中的结点数等于所有结点的度数加1</li>
<li>度为m的树种第i层上至多有m的i-1次方个结点(满二叉树)</li>
</ul>
</li>
</ol>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>左子树、右子树</p>
<ol>
<li>二叉树 与 度为2 有序树</li>
</ol>
<blockquote>
<ol>
<li>二叉树可以为空，而度为2的有序树至少有三个结点</li>
<li>二叉树的孩子结点有左右之分，而度为2的有序树孩子结点次序是相对的</li>
</ol>
</blockquote>
<ol start="2">
<li>满二叉树： 一棵高度为h，且含有2的h次方-1个结点的二叉树为满二叉树</li>
</ol>
<p>对于编号为i的结点，若存在，其双亲的编号为[i/2], 左孩子为2i, 右孩子为2i+1</p>
<ol start="3">
<li>完全二叉树: 设一个高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1~n的结点–对应时，称为完全二叉树</li>
</ol>
<blockquote>
<p>性质：</p>
<ol>
<li><p>若i&lt;=[n/2],则结点i为分支结点，否则为叶子结点</p>
</li>
<li><p>叶子结点只可能在层次最大的两层上出现，对于最大层次的叶子结点，都依次排在最左边的位置上</p>
</li>
<li><p>度为1的结点若存在，则可能有一个，且为编号最大的分支结点，左孩子结点</p>
</li>
</ol>
</blockquote>
<ol start="4">
<li><p>二叉排序树： 一棵二叉树，对任意结点若存在左子树或右子树，则其左子树上所有结点的关键字均小于该结点，右子树上所有结点的关键字均大于该结点</p>
</li>
<li><p>平衡二叉树： 树上任意结点的左子树和右子树的<em>深度</em>之差不超过1 </p>
</li>
</ol>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li><p>非空二叉树上的叶子结点数等于度为2的结点数加1，即n0 = n2 + 1</p>
</li>
<li><p>非空二叉树上第k层上至多有2的k-1次方个结点</p>
</li>
<li><p>高度为h的二叉树至多有2的h次方-1个结点</p>
</li>
<li><p>二叉树：结点i所在层次为[log2 i]+1</p>
</li>
<li><p>具有n个结点的完全二叉树的高度为[log2 n]+1或[log2 (n+1)]</p>
</li>
</ol>
<h3 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h3><ul>
<li>用一组连续的存储单元依次自上而下，自左至右存储完全二叉树上的结点元素</li>
</ul>
<p>(添加不存在的结点数为0)</p>
<ul>
<li><p>链式存储</p>
<p>用链表来存放一棵二叉树，二叉树中每个结点用链表的一个链结点来存储</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<p>含有n个结点的二叉链表中，有n+1个空链域</p>
</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>按某条搜索路径访问树中的每个结点，树的每个结点均被访问一次，而且只访问一次</p>
<p>先序、中序、后序 </p>
<ul>
<li><p>先序遍历</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">void PreOrder (BiTree <span class="literal">T</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">T</span>!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">   visit(<span class="literal">T</span>);</span><br><span class="line">   PreOrder(<span class="literal">T</span>-&gt;lchild);</span><br><span class="line">   PreOrder(<span class="literal">T</span>-&gt;rchild);          <span class="comment"># 递归调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：借助栈</p>
<blockquote>
<p>1.初始时，依次扫描根结点的所有左侧结点并将它们一一进栈；</p>
<p>2.出栈一个结点，访问它</p>
<p>3.扫描该结点的右孩子结点并将其进栈</p>
<p>4.扫描右孩子结点的所有左侧结点并一一进栈；</p>
<p>5.反复该过程直到栈空为止。</p>
</blockquote>
</li>
<li><p>算法</p>
</li>
<li><pre><code class="c"><span class="keyword">void</span> InOrder@(BiTree T){
   InitStack(S); BiTree p = T;
   <span class="keyword">while</span>(p||IsEmpty(S)){
     <span class="keyword">if</span>(p){
        push(S,p);
        p=p-&gt;lchild;
     }
     <span class="keyword">else</span>{
        Pop(S,p); visit(p);
        p=p-&gt;rchild;
     }
   }
}
&lt;!--￼<span class="number">32</span>--&gt;</code></pre>
</li>
<li><p>由遍历序列构造二叉树</p>
</li>
</ul>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><ol>
<li>线索化</li>
</ol>
<blockquote>
<p>若无左子树，则将左指针指向其前驱结点</p>
<p>若无右子树，则将右指针指向其后继结点</p>
</blockquote>
<ol start="2">
<li>线索二叉树结点结构</li>
</ol>
<p>ltag  +  lchild  +  data  +  rchild  +  rtag</p>
<blockquote>
<p>标志域 ltag / rtag ，  若为0， 则左指针域/右指针域指示结点的左(右)孩子</p>
<p>​                                     若为1， 则 左指针域/右指针域指示 结点的前(后)继</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">&#125;ThreadNode, *ThreadTree;           # 线索链表</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C3.png" alt="3"></p>
<blockquote>
<ul>
<li><p>前驱结点</p>
<p>若左指针为线索，则其指向结点为前驱结点</p>
<p>若左指针为左孩子，则其左子树的最右侧结点为前驱结点</p>
</li>
<li><p>后继节点</p>
<p>若右指针为线索，则其指向结点为后继结点</p>
<p>若右指针为右孩子，则其右子树的最左侧结点为后继节点</p>
</li>
</ul>
</blockquote>
<ol start="3">
<li>中序线索二叉树(常用)线索化</li>
</ol>
<ul>
<li><p>若左指针为空，则标记域记为1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">   p-&gt;lchild = pre;</span><br><span class="line">   p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li>中序线索二叉树遍历</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">   p = p-&gt;lchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        reutn p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p=Firstnode(T); p!=<span class="literal">NULL</span>; p=Nextnode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ol>
<li>双亲表示法</li>
</ol>
<p>采用一组连续的存储空间来存储每个节点，同事在每个结点中增设一个伪指针，指示双亲结点在数组中的位置。根结点的下标为0，其伪指针域为-1</p>
<blockquote>
<p>​            <strong>0</strong>        <em>1</em>       2           3</p>
<p>data     R        A        B         C</p>
<p>parent  -1      <strong>0</strong>          <strong>0</strong>         <em>1</em>            </p>
<ul>
<li>即每个结点的伪指针指示其双亲结点的存放位置下标</li>
</ul>
</blockquote>
<ol start="2">
<li>孩子表示法</li>
</ol>
<p>将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表。</p>
<ol start="3">
<li>孩子兄弟表示法</li>
</ol>
<p>以二叉链表作为树的存储结构，又称二叉树表示法</p>
<p>与方法二类似用十字链表实现存储</p>
<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C4.png" alt="4"></p>
<h3 id="树、森林和二叉树的转换"><a href="#树、森林和二叉树的转换" class="headerlink" title="树、森林和二叉树的转换"></a>树、森林和二叉树的转换</h3><ul>
<li><p>树与二叉树的转换</p>
<p>规则：每个结点的左孩子保留，右孩子指向它在树中相邻兄弟结点</p>
</li>
<li><p>森林与二叉树的转换</p>
<p>规则：将每一棵树转换为二叉树，将每棵二叉树的根依次作为上一棵二叉树的右子树</p>
</li>
</ul>
<ol start="2">
<li>数和森林的遍历</li>
</ol>
<ul>
<li>树的先根遍历序列与这棵树对应二叉树的先序遍历序列相同</li>
<li>树的后根遍历序列与这棵树对应二叉树的中序遍历序列相同</li>
</ul>
<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C5.png" alt="5"></p>
<ol start="3">
<li>森林的遍历</li>
</ol>
<ul>
<li><p>先序遍历</p>
<p>依次访问每棵树</p>
<ul>
<li>森林的先序遍历序列与森林对应二叉树的先序遍历序列相同</li>
</ul>
</li>
<li><p>中序遍历</p>
<p>中序遍历第一课时的根结点的子树森林，访问第一棵树的根节点，再访问其他树</p>
<ul>
<li>森林的中序遍历序列与森林对应二叉树的中序遍历序列相同</li>
</ul>
</li>
</ul>
<ol start="4">
<li>遍历序列的对应关系</li>
</ol>
<blockquote>
<p>   树                               森林                      二叉树</p>
<p>先根遍历                   先序遍历                先序遍历</p>
<p>后根遍历                   中序遍历                中序遍历 </p>
</blockquote>
<h3 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h3><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>一种简单的集合表示，通过用树的<em>双亲表示法</em>作为并查集的存储结构</p>
<blockquote>
<p>并查集的三个操作</p>
<p>Initial(S):将集合S中的每个元素都初始化为只有一个单元素的子集合</p>
<p>Union(S,Root1,Root2):把集合S中的子集合(互不相交)Root2并入子集合Root1</p>
<p>Find(S,x): 查找集合S中单元素x所在子集合，并返回该子集合的名字</p>
</blockquote>
<ul>
<li>用双亲表示时，有几个节点，parent 值就为 -几</li>
</ul>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><ul>
<li>BST,也称二叉查找树</li>
<li>若左子树为空，则左子树上所有节点关键字值均小于根节点的关键字</li>
<li>若右子树为空，则右子树上所有节点关键字值均大于根节点的关键字</li>
<li>左/右子树本身也分别是一棵二叉排序树<ul>
<li>中序遍历：左子树值&lt;根节点值&lt;右子树值</li>
</ul>
</li>
</ul>
<ol>
<li>查找</li>
</ol>
<p>查找根节点，若相等则查找成功；</p>
<p>若不相等，则当小于根结点值时，查找左子树，当大于根节点的值时，查找右子树。</p>
<p>当查找到叶结点仍没查找到相应的值，则查找失败</p>
<ol start="2">
<li>插入</li>
</ol>
<p>若二叉排序树为空，则直接插入结点；</p>
<p>若二叉排序树非空，当值小于根结点时，插入左子树；当值大于根结点时，插入右子树，当值等于根结点时不进行插入</p>
<ol start="3">
<li>构造二叉排序树</li>
</ol>
<p>读入一个元素并建立结点，若二叉树为空将其作为根结点；</p>
<p>若二叉排序树非空，当值小于根结点时，插入左子树，当值大于根节点时，插入右子树，当值等于根节点时不进行插入</p>
<ol start="4">
<li>删除</li>
</ol>
<ul>
<li>叶子结点直接删除</li>
<li>若被删除结点只有一颗子树，直接连接到双亲结点</li>
<li>若被删除节点有两棵子树，则让其中序序列直接后继代替，并删去直接后继结点，然后再继续递归调用，最后使用第二个规则完成删除 </li>
</ul>
<ul>
<li><p><em>查找效率</em></p>
<p>平均查找长度(ASL)取决于树的高度</p>
<p>{2,1,4,3}按方法3.构造二叉排序树后</p>
<p>其ASL=(1+2*2+3)/4=2,根据经历的结点个数来计算</p>
</li>
</ul>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>AVL，任意结点的平衡因子的绝对值不超过一</p>
<p><em>左子树高度-右子树高度</em></p>
<ol>
<li>平衡二叉树的判断</li>
</ol>
<p>利用递归的后续遍历过程：</p>
<ul>
<li>判断左子树是一棵平衡二叉树</li>
<li>判断右子树是一棵平衡二叉树</li>
<li>判断以该结点为根的二叉树为平衡二叉树</li>
</ul>
<ol start="2">
<li>平衡二叉树的插入</li>
</ol>
<p>先插入再调整  </p>
<ul>
<li><p>LL平衡选择(右单旋转)</p>
<p>右旋操作：将A的左孩子B代替A，将A结点称为B的右子树根结点，而B的原右子树则作为A的左子树</p>
</li>
<li><p>RR平衡旋转(左单旋转)</p>
<p>左旋操作：将A的右孩子B代替A，将A结点称为B的左子树根结点，而B的原左子树则作为A的右子树</p>
</li>
<li><p>LR平衡旋转(先左后右双旋转)</p>
<p>先左旋后右旋</p>
<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C7.png" alt="7"></p>
</li>
</ul>
<ul>
<li>RL平衡旋转(先右后左双旋转)</li>
</ul>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>路径长度：路径上所经历边的个数</p>
<p>结点的权：结点被赋予的数值</p>
<p>带权路径长度：WPL，树中所有叶结点的带权路径长度之和</p>
<p>哈夫曼树：也称最优二叉树，含有n个带权叶子结点带权路径长度最小的二叉树</p>
<ol>
<li><p>哈夫曼树的构造算法</p>
<blockquote>
<ul>
<li>将n个结点作为n棵仅含有一个根节点的二叉树，构成森林F</li>
<li>生成一个新结点，并从F中找出根节点权值最小的两棵树作为它的左右子树，且新结点的权值为两棵子树根节点的权值之和；</li>
<li>从F中删除着两个树，并将新生成的树加入F中</li>
<li>重复2，3步骤，直到F中只有一棵树为止</li>
</ul>
</blockquote>
</li>
<li><p>性质</p>
<blockquote>
<ul>
<li>每个初始结点都会成为叶结点，双支结点都为新生成的结点</li>
<li>权值越大离根结点越近，反之权值越小离根结点越远</li>
<li>哈夫曼树中没有结点的度为1</li>
<li>n个叶子结点的哈夫曼树的结点总数为2n-1，其中度为2的结点数为n-1</li>
</ul>
</blockquote>
</li>
<li><p>应用</p>
<p>编码：对于一个字符串序列，用二进制来表示字符</p>
<p>哈夫曼树并不唯一，所以每个字符对应的哈夫曼树编码也不唯一但带权路径长度相同且最优</p>
</li>
</ol>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的逻辑结构和相关概念"><a href="#图的逻辑结构和相关概念" class="headerlink" title="图的逻辑结构和相关概念"></a>图的逻辑结构和相关概念</h3><p>图G由顶点集V 和 边集E 组成，记为G=(V,E),(图不能为空)</p>
<p>其中V表示图G中顶点的有限非空集，E表示图G中顶点之间的边集合</p>
<p>|V|表示图G中顶点的个数，称为图G的阶，</p>
<p>|E|表示图G中边的条数</p>
<ul>
<li><p>无向图&amp;有向图</p>
</li>
<li><p>简单图：无重复边，不存在结点到自身的边</p>
<p>多重图：存在重复边，或存在结点到自身的边</p>
</li>
<li><p>完全图</p>
<ul>
<li>无向完全图 任意两个顶点之间都存在边</li>
<li>有向完全图 任意两个顶点之间都存在放心相反的弧</li>
</ul>
</li>
<li><p>子图</p>
<p>设有两个图G=(V,E)和G’=(V’,E’)，若V’是V的子集，且E’是E的子集，则称G’为G的子图</p>
</li>
<li><p>无向图：连通(V和W是连通的)</p>
<p>有向图：强连通(V到W，W到V)</p>
</li>
<li><p>连通图：任意两个结点之间都是连通的</p>
<p>强连通图：任意两个结点之间都是强连通的</p>
<ul>
<li>n个顶点的连通图(强连通图)最少有 n-1 条边</li>
</ul>
</li>
<li><p>连通分量 – 极大连通子图(不存在另一个子图能包含)</p>
<p>强连通分量 – 极大强连通子图</p>
</li>
<li><p>生成树：连通图包含全部顶点的一个极小连通子图</p>
<ul>
<li>n个顶点图的生成树有n-1条边</li>
</ul>
<p>生成森林： 非连通图所有连通分量的生成树组成生成森林</p>
</li>
<li><p>顶点的度：以该顶点为一个端点的边的数目</p>
<ul>
<li>无向图的度：以顶点V为端点的边的个数，记TD(V)</li>
<li>有向图的度：<ul>
<li>出度：以V为起点的有向边的条数，OD(V)</li>
<li>入度：以V为终点的有向边的条数,ID(V)</li>
</ul>
</li>
</ul>
</li>
<li><p>网：对边增加权重</p>
</li>
<li><p>稠密图：边多的图；  稀疏图：边少的图</p>
<ul>
<li>稀疏稠密的界定：|E|&lt;Vlog|V|  (边数小于顶点*顶点log值)</li>
</ul>
</li>
<li><p>有向树：一个顶点的入度为0、其余顶点的入度均为1的有向图</p>
</li>
<li><p>路径：</p>
</li>
<li><p>路径长度：路径上边的数目，若该路径最短则称其为距离</p>
</li>
<li><p>回路：第一个顶点和最后一个顶点相同的路径</p>
</li>
</ul>
<h3 id="图的存储结构及操作"><a href="#图的存储结构及操作" class="headerlink" title="图的存储结构及操作"></a>图的存储结构及操作</h3><h4 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h4><ul>
<li><p>结点数为n的图G = (V,E)的邻接矩阵A是n*n的</p>
<ul>
<li>有向图</li>
</ul>
<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C8.png" alt="8"></p>
<p>然后通过二维数组存放(权重)</p>
<ul>
<li>无向图–对称阵</li>
<li>无向图中第i行(或第i列)非0元素(非正无穷)的个数为第i个顶点的度</li>
<li>有向图中第i行(第i列)非0元素(非正无穷)的个数为第i个顶点的出度(入度)</li>
</ul>
</li>
<li><p>设图G的邻接矩阵为A，矩阵运算A的n次方 的含义</p>
<p>A的2次方 [2] [5]=2表示从顶点V2到顶点V5长度为2的路径有两条</p>
<ul>
<li>A的n次方[i] [j] 表示从顶点Vi到顶点Vj长度为n的路径有*条</li>
</ul>
</li>
</ul>
<h4 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h4><p>为每一个顶点建立一个单链表存放与它相邻的边</p>
<ul>
<li>顶点表： 采用顺序存储，每个数组元素存放顶点的数据和边表的头指针</li>
<li>边表(出边表)： 采用链式存储，单链表中存放与一个顶点相邻的所有边，一个链表结点表示一条从该顶点到链表结点顶点的边</li>
<li></li>
</ul>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3>]]></content>
  </entry>
  <entry>
    <title>Requests库入门</title>
    <url>/2020/06/14/Requests%E5%BA%93%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Python-Requests库"><a href="#Python-Requests库" class="headerlink" title="Python-Requests库"></a>Python-Requests库</h1><h2 id="Requests库安装"><a href="#Requests库安装" class="headerlink" title="Requests库安装"></a>Requests库安装</h2><p>首先打开win命令行窗口，输入</p>
<pre><code><figure class="highlight plain"><figcaption><span>install requests</span></figcaption><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure></code></pre><p>对安装的ruquests进行测试，打开idea,输入</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import requests</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; r = requests.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; r.status_code</span><br></pre></td></tr></table></figure>

<p>如果显示200，则表示连接成功，失败则重新进行上面的操作，或点击链接到官网下载<a href="http://www.python-requests.org" target="_blank" rel="noopener">This link</a> </p>
<p>若显示200，继续输入</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; r.encoding= <span class="string">'utf-8'</span><span class="comment">#改变网页编码</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; r.text             <span class="comment">#打印内容</span></span><br></pre></td></tr></table></figure>

<p>打印内容如下</p>
<img src="http://i2.tiimg.com/721302/001e6e0a3ff2fafe.png" alt="Markdown" style="zoom: 33%;">

<p>这就是我们从网页中爬取出来的代码，然后就可以从中得到我们想要的信息</p>
<h3 id="附：Requests库的7个主要方法"><a href="#附：Requests库的7个主要方法" class="headerlink" title="附：Requests库的7个主要方法"></a>附：Requests库的7个主要方法</h3><p><img src="http://i2.tiimg.com/721302/91bb062aff25063e.png" alt="Markdown"></p>
<h2 id="Requests库的主要方法"><a href="#Requests库的主要方法" class="headerlink" title="Requests库的主要方法"></a>Requests库的主要方法</h2><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>(其实requests库的所有方法都可以归为get方法进行操作，而且这些方法都要在get到想爬取网页的基础上进行)</p>
<p>调用方法</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">r = requests.<span class="builtin-name">get</span>(url，<span class="attribute">params</span>=None,**Kwargs)</span><br><span class="line">​```url：拟获取页面的url链接</span><br><span class="line">   params：url中的额外参数，字典或字节流格式，可选</span><br><span class="line">   **Kwargs：12个控制访问的参数,可选</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">使用方法：打开idea，输入</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>import requests<br>r = requests.get(“<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">http://www.baidu.com&quot;</a>)<br>r.status_code<br> #若显示200则表示连接成功<br>type(r)<br> &lt;class ‘requests.models.Response’&gt;<br>r.headers<br> #(返回get请求页面的头部信息){‘Cache-Control’: ‘private, no-cache, no-store, proxy-revalidate, no-transform’, ‘Connection’: ‘keep-alive’, ‘Content-Encoding’: ‘gzip’, ‘Content-Type’: ‘text/html’, ‘Date’: ‘Mon, 15 Jun 2020 08:23:48 GMT’, ‘Last-Modified’: ‘Mon, 23 Jan 2017 13:28:24 GMT’, ‘Pragma’: ‘no-cache’, ‘Server’: ‘bfe/1.0.8.18’, ‘Set-Cookie’: ‘BDORZ=27315; max-age=86400; domain=.baidu.com; path=/‘, ‘Transfer-Encoding’: ‘chunked’}</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">Response的属性</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">![Markdown](http://i2.tiimg.com/721302/7ba19b27e376db3a.png)</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">get方法一般使用步骤</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">![Markdown](http://i2.tiimg.com/721302/437129653db994a5.png)</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">如果在打印内容r.text的时候，发现都是乱码，该如何操作？</span></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>r.encoding<br> #返回该网页编码 ‘ISO-8859-1’<br>r.apparent_encoding<br> #’uft-8’<br>r.encoding = ‘uft-8’</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这样就可以获取中文的字符，包括该网页(百度)的相关信息</span><br><span class="line"></span><br><span class="line">接下来分析一下Response的编码，如果r.encoding不能正确解码时，就采用r.apparent_encoding来进行解码操作，获取我们想要的信息.</span><br><span class="line"></span><br><span class="line">![<span class="string">Markdown</span>](<span class="link">http://i1.fuimg.com/721302/b71e6da6b12f7774.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##  理解Requests库的异常</span></span><br><span class="line"></span><br><span class="line">一共有6种常用的连接异常</span><br><span class="line"></span><br><span class="line">![<span class="string">Markdown</span>](<span class="link">http://i1.fuimg.com/721302/9415c2fbb8f76155.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##  爬取网页的通用代码框架</span></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>import requests<br>def getHTMLText(url):<br>       try:<br>           r = requests.get(url,timeout=30)<br>           r.raise_for_status()#如果状态不是200，引发HTTPError异常<br>           r.encoding = r.apparent_encoding<br>           return r.text<br>       except:<br>           return “产生异常”<br>if <em>name</em> == “<em>main</em>“:<br>       url = “<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">http://www.baidu.com&quot;</a><br>       print(getHTMLText(url))</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">###   HTTP协议Url格式</span></span><br><span class="line"></span><br><span class="line">![Markdown](<span class="keyword">http</span>://i2.tiimg.com/<span class="number">721302</span>/<span class="number">17</span>dcf547e367b301.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP <span class="built_in">URL</span>的理解：</span><br><span class="line"></span><br><span class="line"><span class="built_in">URL</span>是通过HTTP协议存取资源的Internet路径，一个<span class="built_in">URL</span>对应一个数据资源。</span><br><span class="line"></span><br><span class="line"><span class="comment">###  HTTP协议对资源的操作(即Requests库的6个主要函数所对应的功能)</span></span><br><span class="line"></span><br><span class="line">![Markdown](<span class="keyword">http</span>://i2.tiimg.com/<span class="number">721302</span>/<span class="number">99</span>ee6d5a565e0029.png)</span><br><span class="line"></span><br><span class="line">如果我们想获取<span class="built_in">URL</span>的资源可以使用 GET，HEAD方法，如果我们想对<span class="built_in">URL</span>中的资源进行操作，更新，删除可以使用 PUT,POST,PATCH,DELECT.(例如在HTTP协议世界里，网络通道和服务器都是黑盒子，它能看到的只是<span class="built_in">URL</span>链接)，</span><br><span class="line"></span><br><span class="line"><span class="comment">###  小结</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>requests库的<span class="number">7</span>个常用方法</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>爬取网页的通用代码框架</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>异常处理</span><br><span class="line"></span><br><span class="line"><span class="comment">###  小测试： “任意”找个url，测试一下成功爬取100次网页的时间 </span></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">&gt;&gt;&gt;import requests</span><br><span class="line">&gt;&gt;&gt;import <span class="built_in">time</span></span><br><span class="line">&gt;&gt;&gt;def getHTMLText(url):</span><br><span class="line">       <span class="keyword">try</span>:</span><br><span class="line">           r = requests.<span class="built_in">get</span>(url, timeout=<span class="number">30</span>)</span><br><span class="line">           r.raise_for_status()</span><br><span class="line">           r.encoding = r.apparent_ecoding</span><br><span class="line">           <span class="literal">return</span> r.<span class="keyword">text</span></span><br><span class="line">       except:</span><br><span class="line">           <span class="literal">return</span> <span class="string">"产生异常"</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">       <span class="built_in">start</span> = <span class="built_in">time</span>.perf_counter()</span><br><span class="line">       url = <span class="string">"https://www.sina.com"</span></span><br><span class="line">     </span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">           textstr = getHTMLText(url)</span><br><span class="line">       dur = <span class="built_in">time</span>.perf_counter() - <span class="built_in">start</span></span><br><span class="line">       print(<span class="string">"爬取100次网页的时间为&#123;:5f&#125;s"</span>.<span class="built_in">format</span>(dur))</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
</search>
