
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>数据结构 - ( ๑ˊ•̥▵•)੭の博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Studying,"> 
    <meta name="description" content="a simple webe page for recording,123456title: 数据结构date: 2020-06-26 08:00:30tags: - 数据结构categories:- 基础



绪论数据结构在学什么？

如何用程序代码把现实世界的,"> 
    <meta name="author" content="Sun Huan"> 
    <link rel="alternative" href="atom.xml" title="( ๑ˊ•̥▵•)੭の博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">( ๑ˊ•̥▵•)੭の博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">数据结构</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">数据结构</h1>
        <div class="stuff">
            <span>六月 26, 2020</span>
            

        </div>
        <div class="content markdown">
            <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: 数据结构</span><br><span class="line">date: 2020<span class="string">-06</span><span class="string">-26</span> 08:00:30</span><br><span class="line"><span class="keyword">tags:</span> </span><br><span class="line">- 数据结构</span><br><span class="line">categories:</span><br><span class="line">- 基础</span><br></pre></td></tr></table></figure>



<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>数据结构在学什么？</p>
<ul>
<li><p>如何用程序代码把现实世界的问题信息化</p>
</li>
<li><p>如何用计算机高效地处理这些信息从而创造价值</p>
</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上：   C、数据结构<span class="comment">(软件)</span></span><br><span class="line">        操作系统             通过计算机网络    互联互通</span><br><span class="line">下：    计组<span class="comment">(硬件)</span></span><br></pre></td></tr></table></figure>

<h3 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h3><ul>
<li><p>数据</p>
</li>
<li><p>数据元素、数据项</p>
</li>
<li><p>数据对象、数据结构</p>
</li>
<li><p>数据类型、抽象数据类型</p>
<p>数据类型：是一个值的集合和定义在此集合上的一组操作的总称</p>
<p>​         例：bool类型： true和false ，操作：与或非</p>
<p>抽象数据类型：用数学化语言定义数据和逻辑结构、定义运算、与具体存储结构无关。</p>
</li>
</ul>
<h3 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h3><ul>
<li><p>逻辑结构：线性-树形-图结构</p>
</li>
<li><p>存储(物理)结构：顺序存储-链式-索引-散列存储(哈希)</p>
</li>
<li><p>数据的运算：运算的定义是针对逻辑结构的，运算的实习是针对存储结构的</p>
</li>
</ul>
<p>在讨论一种数据结构时：</p>
<ol>
<li>定义逻辑结构(数据元素之间的关系)</li>
<li>定义数据运算</li>
<li>确定存储结构，实现数据结构</li>
</ol>
<p>程序=数据结构+算法</p>
<p>算法：有穷性、确定性、可行性、输入、输出</p>
<p>好算法：算法执行省时、省内存</p>
<p>​                时间复杂度低、空间复杂度低</p>
<p>算法时间复杂度</p>
<p><em>事前预估算法时间开销T与问题规模n的关系</em></p>
<p>T1(n)=O(n)<strong>大O表示同阶，同等数量级</strong></p>
<p>且在计算时间复杂度时：多项相加，只保留最高阶的项，且系数变为1</p>
<p>​                                           多项相乘，都保留</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">O(1)</span>&lt;<span class="constructor">O(<span class="params">log2</span> <span class="params">n</span>)</span>&lt;<span class="constructor">O(<span class="params">n</span>)</span>&lt;<span class="constructor">O(<span class="params">nlog2</span> <span class="params">n</span>)</span>&lt;<span class="constructor">O(<span class="params">n</span>²)</span>&lt;<span class="constructor">O(<span class="params">n</span>³)</span>&lt;<span class="constructor">O(2的<span class="params">n</span>次方)</span>&lt;<span class="constructor">O(<span class="params">n</span>!)</span>&lt;<span class="constructor">O(<span class="params">n</span>的<span class="params">n</span>次方)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>顺序执行的代码忽略常数项</li>
<li>只考虑循环中的执行次数与n的关系</li>
</ul>
<p>空间复杂度</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">普通程序：找到所占空间大小与问题规模相关的变量，然后分析之间关系<span class="variable">x</span>=<span class="function"><span class="title">f</span>(<span class="variable">n</span>)，</span></span><br><span class="line"><span class="function">即算法空间复杂度=<span class="variable">x</span>的数量级<span class="title">O</span>(<span class="variable">x</span>)</span></span><br><span class="line">递归程序：递归调用的深度<span class="variable">x</span>=问题规模<span class="function"><span class="title">f</span>(<span class="variable">n</span>)，<span class="variable">x</span>的数量级<span class="title">O</span>(<span class="title">f</span>(<span class="variable">n</span>))就是算法空间复杂度</span></span><br><span class="line"><span class="function">计算： 加法规则：取复杂度最大</span></span><br><span class="line"><span class="function">     乘法规则：相乘</span></span><br></pre></td></tr></table></figure>

<h2 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h2><h3 id="线性表的定义和基本操作"><a href="#线性表的定义和基本操作" class="headerlink" title="线性表的定义和基本操作"></a>线性表的定义和基本操作</h3><p>线性表也是一种逻辑结构，表示元素之间一对一相邻的关系</p>
<p>​            是具有<em>相同类型</em>的n个元素的<strong>有限序列</strong>，n为表长、当n=0时为空表</p>
<p>特点：个数有限、排序有先后次序、数据类型都相同</p>
<p><em>基本操作</em></p>
<ul>
<li>InitList(&amp;L)：初始化表，</li>
<li>DestroyList(&amp;L)销毁操作</li>
<li>LocateElem(L,e):按值查找</li>
<li>GetElem(L,i):按位查找</li>
<li>ListInsert(&amp;L,i,e):插入操作，前插</li>
<li>ListDelete(&amp;L,i,&amp;e):删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值</li>
<li>PrintList(L)：输出操作</li>
<li>Empty(L)：判空操作，若L为空表，则返回TRUE，否则返回FALSE</li>
<li>Length(L):求表长</li>
</ul>
<h3 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h3><p>顺序表</p>
<p>逻辑上相邻的元素，内存中位置也相邻<em>(地址=基址+变址)</em></p>
<p>顺序表定义</p>
<ul>
<li><p>数组静态分配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MaxSize 50         #定义数组最大容量</span><br><span class="line">typedef struct&#123;           #结构体</span><br><span class="line">   ElemType data[MaxSize];   #ElemType类型的数组</span><br><span class="line">   int length            #顺序表的长度</span><br><span class="line">&#125;SqList;                #SqList代表该结构体的名字</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>数组动态分配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MaxSize 50        </span><br><span class="line">typedef struct&#123;           </span><br><span class="line">   ElemType *data;        #用指针定义第一个单元地址  </span><br><span class="line">   int length            </span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><em>动态分配语句：</em> C ：L.data=(Elemtype*<em>)malloc(sizeof(ElemType)</em>乘InitSize)_</p>
<p>​                                  Elemtype*  ：强制类型转换，后边分配地址</p>
<h4 id="基本操作："><a href="#基本操作：" class="headerlink" title="基本操作："></a>基本操作：</h4><ul>
<li>插入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool ListInsert(SqList  &amp;L,  int  i,ElemType   e)&#123; </span><br><span class="line">    # i 是顺序表的标号，不是数组下标</span><br><span class="line">      if(i&lt;1 ||i&gt;L.length+1)</span><br><span class="line">              return false;</span><br><span class="line">      if(L.length&gt;&#x3D;MaxSize)</span><br><span class="line">              return  false;</span><br><span class="line">     for(int j&#x3D;L.length ;  j&gt;&#x3D;i ;   j--)</span><br><span class="line">              L.data[j]&#x3D;L.data[i-1];</span><br><span class="line">      L.data[i-1]&#x3D;e;</span><br><span class="line">      L.length++; </span><br><span class="line">      return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">** L.data[i-1]&#x3D;e;      i-1是数组下标对应顺序表第i个元素</span><br></pre></td></tr></table></figure>

<ul>
<li>删除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool ListDelete(SqList  &amp;L,  int  i,ElemType e)&#123;</span><br><span class="line">  if(i&lt;1||i&gt;L.length)</span><br><span class="line">    return false;</span><br><span class="line">  e&#x3D;L.data[i-1];</span><br><span class="line">  for(int j&#x3D;1; j&lt;L.length; j++)</span><br><span class="line">    L.data[j-1]&#x3D;L.data[j];</span><br><span class="line">  L.length--;</span><br><span class="line">  return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>按值查找</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">         <span class="keyword">if</span>(L.data[i]==e)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;  #当找到值对应的顺序表的位置时，</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;          #返回的是它的顺序表标号    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h3><p>单链表</p>
<p>通过一组任意的存储单元来存储线性表中的数据元素</p>
<p>不仅存储数据本身，还存储下一个数据的地址</p>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure>

<p><em>判断单链表L为空</em></p>
<ol>
<li>不带，head == null时，</li>
<li>带有头结点，head -&gt;next为null时，</li>
</ol>
<h4 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h4><ol>
<li>头插法(直接插入元素)</li>
</ol>
<p><em>s.next=L.next<br>L.next=s</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkList List_HeadInsert (LinkList  &amp;L)&#123;</span><br><span class="line">    LNode  *s; int  x;</span><br><span class="line">    L-&gt;next&#x3D;NULL;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    while(x!&#x3D;9999)&#123;</span><br><span class="line">        s&#x3D;(LNode*)malloc(sizeof(LNode));</span><br><span class="line">        s-&gt;data&#x3D;x;</span><br><span class="line">        s-&gt;next&#x3D;L-&gt;next;</span><br><span class="line">        L-&gt;next&#x3D;s;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>尾插法(直接插入元素)</li>
</ol>
<p><em>r-&gt;next=s</em></p>
<p><em>r=s</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LinkList List_HeadInsert (LinkList  &amp;L)&#123;</span><br><span class="line">    int  x;</span><br><span class="line">    L&#x3D;(LinkList)malloc(sizeof(LNode));</span><br><span class="line">    LNode *s,*r &#x3D;L;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    while(x!&#x3D;9999)&#123;</span><br><span class="line">        s&#x3D;(LNode*)malloc(sizeof(LNode));</span><br><span class="line">        s-&gt;data&#x3D;x;</span><br><span class="line">        r-&gt;next&#x3D;s;</span><br><span class="line">        r&#x3D;s;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next&#x3D;NULL;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>按序号查找&amp;按值查找</p>
<p>都要遍历单链表</p>
</li>
</ol>
<ol start="4">
<li>插入节点</li>
</ol>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p=GetElem(L.i<span class="number">-1</span>);   通过查找到第i个节点的位置</span><br><span class="line">s-&gt;<span class="keyword">next</span>=p-&gt;<span class="keyword">next</span>;</span><br><span class="line">p-&gt;<span class="keyword">next</span>=s;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>删除</li>
</ol>
<p><strong>p=GetElem(L,i-1);</strong></p>
<p><strong>q=p-&gt;next;</strong></p>
<p><strong>p-&gt;next=q-&gt;next;</strong></p>
<p><strong>free(q);</strong></p>
<p>(2) 删除给点节点(数据交换)</p>
<p><em>q=p-&gt;next;</em></p>
<p><em>p-&gt;data=p-&gt;next-&gt;data;</em></p>
<p><em>p-&gt;next=q-&gt;next;</em></p>
<p><em>free(q);</em></p>
<ol start="6">
<li>求表长</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int count&#x3D;0;</span><br><span class="line"></span><br><span class="line">while(p-&gt;next!&#x3D;NULL)&#123;</span><br><span class="line"></span><br><span class="line">cout++;</span><br><span class="line"></span><br><span class="line">p&#x3D;p-&gt;next;&#125;</span><br></pre></td></tr></table></figure>

<p>注：<em>引入头结点，能够统一空表和非空表的判断</em></p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">      ElemType data;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>  *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode, *DLinkList;</span><br></pre></td></tr></table></figure>

<p>循环链表：循环单链表、循环双链表</p>
<p>静态链表：数组实现</p>
<h3 id="顺序表与链表的比较"><a href="#顺序表与链表的比较" class="headerlink" title="顺序表与链表的比较"></a>顺序表与链表的比较</h3><ol>
<li><p>存取方式</p>
<p>顺序表 可以实现顺序存取和随机存取</p>
<p>单链表 只能实现顺序存取</p>
</li>
<li><p>逻辑结构和物理地址</p>
<p>顺序表 逻辑相邻物理上也相邻，通过相邻表示逻辑关系</p>
<p>单链表 逻辑相邻物理上不一定相邻，通过指针表示逻辑关系</p>
</li>
<li><p>基本操作</p>
</li>
<li><p>内存空间</p>
<p>顺序存储 无论静态分配还是非静态都需要预先分配合适的内存空间</p>
<p>​      静态分配：太大浪费、太小溢出</p>
<p>​      动态分配： 扩充时需要大量移动元素、操作效率低</p>
<p>链式存储 在需要时分配结点空间即可，高效方便，但指针要使用额外空间</p>
</li>
</ol>
<p>怎样选择线性表的存储结构？</p>
<p>当存储规模难估计 ——  单链表</p>
<p>存储密度大             ——  顺序表按序号</p>
<p>按序号访问时         ——  顺序表 </p>
<p>插入和删除             —— 单链表 </p>
<p>基于数组                 —— 顺序表</p>
<p>基于指针                 —— 单链表</p>
<p><em>3个常用操作</em></p>
<ul>
<li><p>最值</p>
<p>顺序表：遍历，  链表：用两个指针来移动比较</p>
</li>
<li><p>转置</p>
<p>顺序表：用两个指针，一个头、一个尾互相交换值，当i=j,或者i&gt;j时结束</p>
<p>链表</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;<span class="keyword">next</span>!=r)&#123;</span><br><span class="line">temp= p-&gt;<span class="keyword">next</span>;</span><br><span class="line">p-&gt;<span class="keyword">next</span>= temp-&gt;<span class="keyword">next</span>;</span><br><span class="line">temp-&gt;<span class="keyword">next</span>=r-&gt;<span class="keyword">next</span>;</span><br><span class="line">r-&gt;<span class="keyword">next</span>=temp;</span><br><span class="line">&#125;                           <span class="comment">#O(n)</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>合并</p>
<p>线性表</p>
</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i=0,j=0;</span><br><span class="line">int k=0;</span><br><span class="line">for(;i&lt;L1.Size&amp;&amp;j&lt;L2.Size;k++)&#123;</span><br><span class="line">  if(L1<span class="comment">[i]</span>&lt;L2<span class="comment">[j]</span>)</span><br><span class="line">   L<span class="comment">[k]</span>=L1<span class="comment">[i++]</span>;</span><br><span class="line">  else</span><br><span class="line">  L<span class="comment">[k]</span>=L2<span class="comment">[j++]</span>;</span><br><span class="line">&#125;</span><br><span class="line">while(i&lt;L1.Size)</span><br><span class="line">L<span class="comment">[k++]</span>=L1<span class="comment">[i++]</span>;</span><br><span class="line">while(j&lt;L2.Size)</span><br><span class="line">L<span class="comment">[k++]</span>=L1<span class="comment">[i++]</span>;                 #O(n)</span><br></pre></td></tr></table></figure>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol>
<li>基本概念(后进先出LIFO)</li>
</ol>
<p>只允许在一端进行插入或删除操作的线性表(栈顶TOP、栈底bottom)</p>
<ol start="2">
<li><p>基本操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InitStack(&amp;S):  初始化一个空栈S</span><br><span class="line">StackEmpty(S):  判断一个栈是否为空，为空---true，否则返回false</span><br><span class="line">Push(&amp;S,&amp;x):   进栈，若栈S未满，则加入x</span><br><span class="line">Pop(&amp;S,&amp;x):    出栈，若栈S非空，则弹出栈顶元素，用x返回</span><br><span class="line">GetTop(S,&amp;x):   读栈顶元素，非空，则返回栈顶元素</span><br><span class="line">ClearStack(&amp;S):  销毁栈，并释放S占用的内存空间</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>栈的顺序存储</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   ElemType data[MaxSize];</span><br><span class="line">   <span class="keyword">int</span> top;            #标识变量top  指向数组尾部的指针</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<ul>
<li>栈空条件   S.top == -1;</li>
<li>栈长       S.top+1;</li>
<li>栈满       S.top==MaxSize-1;</li>
</ul>
<p>（2）共享栈</p>
</li>
</ol>
<p>将两个栈底设置在共享空间的两端，栈顶向空间中间延伸</p>
<p>判空：  0号栈top ==-1</p>
<p>​              1号栈top == MaxSize</p>
<p>栈满：top1-top0==1</p>
<ol start="4">
<li><p>栈的链式存储</p>
<p>所有操作都在表头进行</p>
</li>
</ol>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ol>
<li><p>基本概念(先进先出)</p>
<p>只允许在表的一端进行插入，表的另一端进行删除操作的线性表</p>
</li>
<li><p>基本操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InitQueue(&amp;Q): 初始化队列，构造一个空队列Q</span><br><span class="line">QueueEmpty(Q): 判队列空，若队列Q为空返回true，否则返回false</span><br><span class="line">EnQueue(&amp;Q,x): 入队，若队列Q未满，则将x加入使之成为新的队尾</span><br><span class="line">DeQueue(&amp;Q,&amp;x):出队，若队列Q非空，则删除队头元素，并用x返回</span><br><span class="line">GetHead(Q,&amp;x): 读对头元素，若队列Q非空则用x返回对头元素</span><br><span class="line">ClearQueue(&amp;Q):销毁队列，并释放队列Q占用的内存空间</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储结构实现队列</p>
<p>front指针(队首)—– 出队</p>
<p>rear指针(队尾) —– 入队   </p>
<p>初始化时： front==rear==0</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>队空条件 Q.front==Q.rear （为什么不等于0—当插入一个元素并删除后，两个指针都发生移动，但值不为0）</p>
</li>
<li><p>队长     Q.rear-Q.front</p>
</li>
<li><p>队满    (容易假溢出，我们根据Q.rear=Maxsize来判断，但是当队列有进行过删除操作时，队头有空不满)</p>
<p>所以就有了—</p>
</li>
</ul>
<p>  循环队列</p>
<p>  把存储队列的顺序队列在逻辑上视为一个环</p>
<p>  ​     实现：</p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">front指针移动：</span><br><span class="line">Q.front = (Q.front+<span class="number">1</span>) % MaxSize</span><br><span class="line">rear指针移动：</span><br><span class="line">Q.rear = (Q.rear+<span class="number">1</span>) % MaxSize</span><br><span class="line">队列长度：</span><br><span class="line">(Q.rear+MaxSize-Q.front) % MaxSize</span><br></pre></td></tr></table></figure></code></pre><p>  判断队空和队满：</p>
<ul>
<li>方法一：牺牲一个存储单元</li>
<li>方法二：增加一个变量代表元素的个数</li>
<li>方法三：增加tag标识(当进队时，tag=1，出队时，tag=0)</li>
</ul>
<ol start="4">
<li><p>队列的链式存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<p>判空： Q.front=Q.rear</p>
<p>入队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ENQueue</span><span class="params">(LinkQueue &amp;Q,ElemTyep x)</span></span>&#123;</span><br><span class="line"> LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line"> s-&gt;data = x;</span><br><span class="line"> s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"> Q.rear-&gt;next = s;</span><br><span class="line"> Q.rear = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合法出栈序列：</p>
<p>只要有大的出，剩下比它小的没出的，都要递减出</p>
<ol start="5">
<li>允许在两端都可以进行插入和删除操作的队列</li>
</ol>
<h3 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h3></li>
<li><p>括号匹配</p>
<ul>
<li>一个空栈，顺序读括号</li>
<li>若是右括号，则与栈顶元素进行匹配，匹配则弹出，不匹配则该序列不合法</li>
<li>若是左括号，则压入栈中</li>
<li>若全部元素遍历完毕，栈中非空则序列不合法</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>表达式求值</p>
<p>前缀、中缀、后缀表达式</p>
<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C1.png" alt="1"></p>
</li>
<li><p>递归</p>
</li>
</ol>
<ul>
<li>数组</li>
</ul>
<p>数组是线性表的推广，数组一旦被定义，其维度和维界不可变</p>
<ol>
<li><p>存储结构</p>
<p>行优先、列优先</p>
</li>
</ol>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>压缩存储：你指多个值相同的元素只分配一个存储空间，对零元素不分配存储空间</p>
<p>特殊矩阵：  指具有许多相同矩阵元素或零元素，且这些元素分布有一定规律性</p>
<p><em>特殊矩阵的压缩存储</em>： 找出特殊矩阵中值相同的矩阵元素的分布规律， 把那些呈现规律性分布、值相同的多个矩阵元素压缩存储到一个存储空间上</p>
<ol>
<li>对称矩阵  a-i，j  = a-j，i</li>
</ol>
<p>​         存放数组 B[n(n+1)]/2</p>
<ul>
<li>按行存放：  数组下标 k=1+2+…+(i-1)+j-1+1-1</li>
<li>​              当i&gt;=j   k=i(i-1)/2+j-1  下三角部分</li>
<li>​              当i&lt;j   k=j(j-1)/2+i-1   上三角部分</li>
</ul>
<p>​                                   </p>
<ol start="2">
<li><p>三角矩阵</p>
<p>下三角矩阵：   上三角去元素为同一常量</p>
<p>上三角矩阵：   下三角去元素为同一常量</p>
</li>
<li><p>三对角矩阵</p>
<p>对角线两侧有元素，相当于1条主对角线+附近两条类似对角线</p>
<p>数组下标 k = 3*(i-1)-1+j-i+1+1-1</p>
<p>​            = 2i+j-3</p>
</li>
<li><p>稀疏矩阵：矩阵中非零元素的个数t来说非常多，且分布不规律</p>
<p> 三元组(行标、列表、值)</p>
<p> i   j   value</p>
<p> 0   0     1</p>
</li>
</ol>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><ol>
<li><p>定义：由零个或多个字符组成的有限序列(串中空格也是特殊字符)    </p>
<p>串中任意个连续的字符组成的子序列称为该串的子串，包含子串的串为主串</p>
</li>
<li><p>存储结构</p>
</li>
</ol>
<ul>
<li><p>定长顺序存储:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> ch[MAXLEN];</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆分配存储表示：   malloc()/free() </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> *ch;</span><br><span class="line">   <span class="keyword">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>
</li>
<li><p>块链存储表示：</p>
<p>每一个单链表就是一个块链</p>
</li>
</ul>
<ol start="3">
<li><p>基本操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StrAssign(&amp;T,chars):赋值操作</span><br><span class="line">SriCompare(S,T):比较操作，若S&gt;T，则返回值&gt;0;若S&#x3D;T,则返回值&#x3D;0；若S&lt;T，则返回值&lt;0;</span><br><span class="line">StrLength(S):求串长，返回串S的元素个数</span><br><span class="line">SubString(&amp;Sub, S , pos, len):求子串，用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">Concat(&amp;T, S1, S2):串联接，用T返回由S1和S2联接而成的新串。</span><br><span class="line">Index(S,T,pos):定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第pos个字符后第一次出现的位置；否则函数值为0；</span><br><span class="line">SrtCopy(S):复制操作，由串S复制得到串T</span><br><span class="line">StrEmpty(S):判空操作，若S为空串，返回TRUE，若非空，返回FALSE</span><br><span class="line">Replace(&amp;S, T, V): 替换子串，用V替换主串Szhong出现的所有与T相等的不重叠的子串</span><br><span class="line">StrInsert(&amp;S, pos, len): 删除子串，从串S中删除第pos个字符起长度为len的子串</span><br><span class="line">ClearString(&amp;S): 清空操作，将S请为空串</span><br><span class="line">DestroyString(&amp;S)；销毁串</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="串-模式匹配"><a href="#串-模式匹配" class="headerlink" title="串 模式匹配"></a>串 模式匹配</h3><ol>
<li><p>SubString(&amp;Sub, S , pos, len) 找子串</p>
<p>SriCompare(S,T):比较子串</p>
</li>
<li><p>模式匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int Index(SString S, SString T, int pos)&#123;</span><br><span class="line">  int i&#x3D;pos, j&#x3D;1;</span><br><span class="line">  while(i&lt;&#x3D;S.length &amp;&amp; j&lt;&#x3D;T.length)&#123;</span><br><span class="line">  if(S.ch[i]&#x3D;&#x3D;T.ch[j])&#123;</span><br><span class="line">     i++;</span><br><span class="line">     j++;       #  当第一个字符匹配成功时，继续往后匹配剩下的子串</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">      i&#x3D;i-j+2;   #主串的位置往后移动匹配子串</span><br><span class="line">      j&#x3D;1;      # 子串位置不变</span><br><span class="line">  &#125;</span><br><span class="line">  if(j&gt;T.length)</span><br><span class="line">     return i-T.length;</span><br><span class="line">  else </span><br><span class="line">     return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>和模式匹配一样，重要在于，匹配失败后，跳转到第几个字符</p>
<p>next数组：记录这个前缀和后缀的公共串，方便匹配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">模式串      next[]</span><br><span class="line"> b         next[<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line"> b a        next[<span class="number">2</span>]=<span class="number">0</span></span><br><span class="line"> b a c       next[<span class="number">3</span>]=<span class="number">0</span></span><br><span class="line"> b a c b      next[<span class="number">4</span>]=<span class="number">1</span></span><br><span class="line"> b a c b a     next[<span class="number">5</span>]=<span class="number">2</span></span><br><span class="line"> b a c b a b    next[<span class="number">6</span>]=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>移动序列：  Move = (j-1) - next[j-1]</p>
<p>KMP算法</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void get_next(String T, int net[])&#123;</span><br><span class="line">  int i&#x3D;1, j&#x3D;0;</span><br><span class="line">  next[1]&#x3D;0;</span><br><span class="line">  while(i&lt;T.length)&#123;</span><br><span class="line">    if(j&#x3D;&#x3D;0||T.ch[i]&#x3D;&#x3D;T.ch[j])&#123;</span><br><span class="line">    ++i; ++j;next[i]&#x3D;j;</span><br><span class="line">    &#125;else</span><br><span class="line">       j&#x3D;next[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Index_KMP(String S, String T, int next[], int pos)&#123;</span><br><span class="line">    int i&#x3D;pos, j&#x3D;1;</span><br><span class="line">    while(i&lt;&#x3D;S.length &amp;&amp; j&lt;&#x3D;T.length)&#123;</span><br><span class="line">        if(j&#x3D;&#x3D;0||S.ch[i]&#x3D;&#x3D;T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            j&#x3D;next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    if(j&gt;T.length)</span><br><span class="line">        return i-T.length;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C2.png" alt="2"></p>
<ol>
<li>基本概念</li>
</ol>
<p>树是n个结点的有限集合，n=0时，称为空树</p>
<p>n个结点的树中，只有n-1条边</p>
<p>祖先结点、子孙结点、双亲、孩子结点、兄弟结点</p>
<p>结点的度：树种一个结点的子结点的个数称为该结点的度</p>
<p>树的度：树中所有结点的最大值</p>
<p>度大于0的结点称为分支结点</p>
<p>度为0的结点称为叶子结点</p>
<ul>
<li>结点的层次 从根结点以此 第一层···</li>
<li>结点的高度 经历的层次从底到根</li>
<li>结点的深度 反过来 从根到底经历的层次</li>
</ul>
<p>树的高度(深度)为最大高度</p>
<ul>
<li><p>无序树、有序树</p>
</li>
<li><p>路径 一定是自上而下的，树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的</p>
</li>
</ul>
<p>​       路径长度：路径上经过的边的个数</p>
<ul>
<li>森林： m(M&gt;=0)棵互不相见的树的集合</li>
</ul>
<ol start="2">
<li>树的性质<ul>
<li>树中的结点数等于所有结点的度数加1</li>
<li>度为m的树种第i层上至多有m的i-1次方个结点(满二叉树)</li>
</ul>
</li>
</ol>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>左子树、右子树</p>
<ol>
<li>二叉树 与 度为2 有序树</li>
</ol>
<blockquote>
<ol>
<li>二叉树可以为空，而度为2的有序树至少有三个结点</li>
<li>二叉树的孩子结点有左右之分，而度为2的有序树孩子结点次序是相对的</li>
</ol>
</blockquote>
<ol start="2">
<li>满二叉树： 一棵高度为h，且含有2的h次方-1个结点的二叉树为满二叉树</li>
</ol>
<p>对于编号为i的结点，若存在，其双亲的编号为[i/2], 左孩子为2i, 右孩子为2i+1</p>
<ol start="3">
<li>完全二叉树: 设一个高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1~n的结点–对应时，称为完全二叉树</li>
</ol>
<blockquote>
<p>性质：</p>
<ol>
<li><p>若i&lt;=[n/2],则结点i为分支结点，否则为叶子结点</p>
</li>
<li><p>叶子结点只可能在层次最大的两层上出现，对于最大层次的叶子结点，都依次排在最左边的位置上</p>
</li>
<li><p>度为1的结点若存在，则可能有一个，且为编号最大的分支结点，左孩子结点</p>
</li>
</ol>
</blockquote>
<ol start="4">
<li><p>二叉排序树： 一棵二叉树，对任意结点若存在左子树或右子树，则其左子树上所有结点的关键字均小于该结点，右子树上所有结点的关键字均大于该结点</p>
</li>
<li><p>平衡二叉树： 树上任意结点的左子树和右子树的<em>深度</em>之差不超过1 </p>
</li>
</ol>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li><p>非空二叉树上的叶子结点数等于度为2的结点数加1，即n0 = n2 + 1</p>
</li>
<li><p>非空二叉树上第k层上至多有2的k-1次方个结点</p>
</li>
<li><p>高度为h的二叉树至多有2的h次方-1个结点</p>
</li>
<li><p>二叉树：结点i所在层次为[log2 i]+1</p>
</li>
<li><p>具有n个结点的完全二叉树的高度为[log2 n]+1或[log2 (n+1)]</p>
</li>
</ol>
<h3 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h3><ul>
<li>用一组连续的存储单元依次自上而下，自左至右存储完全二叉树上的结点元素</li>
</ul>
<p>(添加不存在的结点数为0)</p>
<ul>
<li><p>链式存储</p>
<p>用链表来存放一棵二叉树，二叉树中每个结点用链表的一个链结点来存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<p>含有n个结点的二叉链表中，有n+1个空链域</p>
</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>按某条搜索路径访问树中的每个结点，树的每个结点均被访问一次，而且只访问一次</p>
<p>先序、中序、后序 </p>
<ul>
<li><p>先序遍历</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void PreOrder (BiTree <span class="literal">T</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">T</span>!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">   visit(<span class="literal">T</span>);</span><br><span class="line">   PreOrder(<span class="literal">T</span>-&gt;lchild);</span><br><span class="line">   PreOrder(<span class="literal">T</span>-&gt;rchild);          <span class="comment"># 递归调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：借助栈</p>
<blockquote>
<p>1.初始时，依次扫描根结点的所有左侧结点并将它们一一进栈；</p>
<p>2.出栈一个结点，访问它</p>
<p>3.扫描该结点的右孩子结点并将其进栈</p>
<p>4.扫描右孩子结点的所有左侧结点并一一进栈；</p>
<p>5.反复该过程直到栈空为止。</p>
</blockquote>
</li>
<li><p>算法</p>
</li>
<li><pre><code class="c"><span class="keyword">void</span> InOrder@(BiTree T){
   InitStack(S); BiTree p = T;
   <span class="keyword">while</span>(p||IsEmpty(S)){
     <span class="keyword">if</span>(p){
        push(S,p);
        p=p-&gt;lchild;
     }
     <span class="keyword">else</span>{
        Pop(S,p); visit(p);
        p=p-&gt;rchild;
     }
   }
}
&lt;!--￼<span class="number">32</span>--&gt;</code></pre>
</li>
<li><p>由遍历序列构造二叉树</p>
</li>
</ul>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><ol>
<li>线索化</li>
</ol>
<blockquote>
<p>若无左子树，则将左指针指向其前驱结点</p>
<p>若无右子树，则将右指针指向其后继结点</p>
</blockquote>
<ol start="2">
<li>线索二叉树结点结构</li>
</ol>
<p>ltag  +  lchild  +  data  +  rchild  +  rtag</p>
<blockquote>
<p>标志域 ltag / rtag ，  若为0， 则左指针域/右指针域指示结点的左(右)孩子</p>
<p>​                                     若为1， 则 左指针域/右指针域指示 结点的前(后)继</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">&#125;ThreadNode, *ThreadTree;           # 线索链表</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C3.png" alt="3"></p>
<blockquote>
<ul>
<li><p>前驱结点</p>
<p>若左指针为线索，则其指向结点为前驱结点</p>
<p>若左指针为左孩子，则其左子树的最右侧结点为前驱结点</p>
</li>
<li><p>后继节点</p>
<p>若右指针为线索，则其指向结点为后继结点</p>
<p>若右指针为右孩子，则其右子树的最左侧结点为后继节点</p>
</li>
</ul>
</blockquote>
<ol start="3">
<li>中序线索二叉树(常用)线索化</li>
</ol>
<ul>
<li><p>若左指针为空，则标记域记为1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">   p-&gt;lchild = pre;</span><br><span class="line">   p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li>中序线索二叉树遍历</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">   p = p-&gt;lchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        reutn p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p=Firstnode(T); p!=<span class="literal">NULL</span>; p=Nextnode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ol>
<li>双亲表示法</li>
</ol>
<p>采用一组连续的存储空间来存储每个节点，同事在每个结点中增设一个伪指针，指示双亲结点在数组中的位置。根结点的下标为0，其伪指针域为-1</p>
<blockquote>
<p>​            <strong>0</strong>        <em>1</em>       2           3</p>
<p>data     R        A        B         C</p>
<p>parent  -1      <strong>0</strong>          <strong>0</strong>         <em>1</em>            </p>
<ul>
<li>即每个结点的伪指针指示其双亲结点的存放位置下标</li>
</ul>
</blockquote>
<ol start="2">
<li>孩子表示法</li>
</ol>
<p>将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表。</p>
<ol start="3">
<li>孩子兄弟表示法</li>
</ol>
<p>以二叉链表作为树的存储结构，又称二叉树表示法</p>
<p>与方法二类似用十字链表实现存储</p>
<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C4.png" alt="4"></p>
<h3 id="树、森林和二叉树的转换"><a href="#树、森林和二叉树的转换" class="headerlink" title="树、森林和二叉树的转换"></a>树、森林和二叉树的转换</h3><ul>
<li><p>树与二叉树的转换</p>
<p>规则：每个结点的左孩子保留，右孩子指向它在树中相邻兄弟结点</p>
</li>
<li><p>森林与二叉树的转换</p>
<p>规则：将每一棵树转换为二叉树，将每棵二叉树的根依次作为上一棵二叉树的右子树</p>
</li>
</ul>
<ol start="2">
<li>数和森林的遍历</li>
</ol>
<ul>
<li>树的先根遍历序列与这棵树对应二叉树的先序遍历序列相同</li>
<li>树的后根遍历序列与这棵树对应二叉树的中序遍历序列相同</li>
</ul>
<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C5.png" alt="5"></p>
<ol start="3">
<li>森林的遍历</li>
</ol>
<ul>
<li><p>先序遍历</p>
<p>依次访问每棵树</p>
<ul>
<li>森林的先序遍历序列与森林对应二叉树的先序遍历序列相同</li>
</ul>
</li>
<li><p>中序遍历</p>
<p>中序遍历第一课时的根结点的子树森林，访问第一棵树的根节点，再访问其他树</p>
<ul>
<li>森林的中序遍历序列与森林对应二叉树的中序遍历序列相同</li>
</ul>
</li>
</ul>
<ol start="4">
<li>遍历序列的对应关系</li>
</ol>
<blockquote>
<p>   树                               森林                      二叉树</p>
<p>先根遍历                   先序遍历                先序遍历</p>
<p>后根遍历                   中序遍历                中序遍历 </p>
</blockquote>
<h3 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h3><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>一种简单的集合表示，通过用树的<em>双亲表示法</em>作为并查集的存储结构</p>
<blockquote>
<p>并查集的三个操作</p>
<p>Initial(S):将集合S中的每个元素都初始化为只有一个单元素的子集合</p>
<p>Union(S,Root1,Root2):把集合S中的子集合(互不相交)Root2并入子集合Root1</p>
<p>Find(S,x): 查找集合S中单元素x所在子集合，并返回该子集合的名字</p>
</blockquote>
<ul>
<li>用双亲表示时，有几个节点，parent 值就为 -几</li>
</ul>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><ul>
<li>BST,也称二叉查找树</li>
<li>若左子树为空，则左子树上所有节点关键字值均小于根节点的关键字</li>
<li>若右子树为空，则右子树上所有节点关键字值均大于根节点的关键字</li>
<li>左/右子树本身也分别是一棵二叉排序树<ul>
<li>中序遍历：左子树值&lt;根节点值&lt;右子树值</li>
</ul>
</li>
</ul>
<ol>
<li>查找</li>
</ol>
<p>查找根节点，若相等则查找成功；</p>
<p>若不相等，则当小于根结点值时，查找左子树，当大于根节点的值时，查找右子树。</p>
<p>当查找到叶结点仍没查找到相应的值，则查找失败</p>
<ol start="2">
<li>插入</li>
</ol>
<p>若二叉排序树为空，则直接插入结点；</p>
<p>若二叉排序树非空，当值小于根结点时，插入左子树；当值大于根结点时，插入右子树，当值等于根结点时不进行插入</p>
<ol start="3">
<li>构造二叉排序树</li>
</ol>
<p>读入一个元素并建立结点，若二叉树为空将其作为根结点；</p>
<p>若二叉排序树非空，当值小于根结点时，插入左子树，当值大于根节点时，插入右子树，当值等于根节点时不进行插入</p>
<ol start="4">
<li>删除</li>
</ol>
<ul>
<li>叶子结点直接删除</li>
<li>若被删除结点只有一颗子树，直接连接到双亲结点</li>
<li>若被删除节点有两棵子树，则让其中序序列直接后继代替，并删去直接后继结点，然后再继续递归调用，最后使用第二个规则完成删除 </li>
</ul>
<ul>
<li><p><em>查找效率</em></p>
<p>平均查找长度(ASL)取决于树的高度</p>
<p>{2,1,4,3}按方法3.构造二叉排序树后</p>
<p>其ASL=(1+2*2+3)/4=2,根据经历的结点个数来计算</p>
</li>
</ul>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>AVL，任意结点的平衡因子的绝对值不超过一</p>
<p><em>左子树高度-右子树高度</em></p>
<ol>
<li>平衡二叉树的判断</li>
</ol>
<p>利用递归的后续遍历过程：</p>
<ul>
<li>判断左子树是一棵平衡二叉树</li>
<li>判断右子树是一棵平衡二叉树</li>
<li>判断以该结点为根的二叉树为平衡二叉树</li>
</ul>
<ol start="2">
<li>平衡二叉树的插入</li>
</ol>
<p>先插入再调整  </p>
<ul>
<li><p>LL平衡选择(右单旋转)</p>
<p>右旋操作：将A的左孩子B代替A，将A结点称为B的右子树根结点，而B的原右子树则作为A的左子树</p>
</li>
<li><p>RR平衡旋转(左单旋转)</p>
<p>左旋操作：将A的右孩子B代替A，将A结点称为B的左子树根结点，而B的原左子树则作为A的右子树</p>
</li>
<li><p>LR平衡旋转(先左后右双旋转)</p>
<p>先左旋后右旋</p>
<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C7.png" alt="7"></p>
</li>
</ul>
<ul>
<li>RL平衡旋转(先右后左双旋转)</li>
</ul>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>路径长度：路径上所经历边的个数</p>
<p>结点的权：结点被赋予的数值</p>
<p>带权路径长度：WPL，树中所有叶结点的带权路径长度之和</p>
<p>哈夫曼树：也称最优二叉树，含有n个带权叶子结点带权路径长度最小的二叉树</p>
<ol>
<li><p>哈夫曼树的构造算法</p>
<blockquote>
<ul>
<li>将n个结点作为n棵仅含有一个根节点的二叉树，构成森林F</li>
<li>生成一个新结点，并从F中找出根节点权值最小的两棵树作为它的左右子树，且新结点的权值为两棵子树根节点的权值之和；</li>
<li>从F中删除着两个树，并将新生成的树加入F中</li>
<li>重复2，3步骤，直到F中只有一棵树为止</li>
</ul>
</blockquote>
</li>
<li><p>性质</p>
<blockquote>
<ul>
<li>每个初始结点都会成为叶结点，双支结点都为新生成的结点</li>
<li>权值越大离根结点越近，反之权值越小离根结点越远</li>
<li>哈夫曼树中没有结点的度为1</li>
<li>n个叶子结点的哈夫曼树的结点总数为2n-1，其中度为2的结点数为n-1</li>
</ul>
</blockquote>
</li>
<li><p>应用</p>
<p>编码：对于一个字符串序列，用二进制来表示字符</p>
<p>哈夫曼树并不唯一，所以每个字符对应的哈夫曼树编码也不唯一但带权路径长度相同且最优</p>
</li>
</ol>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的逻辑结构和相关概念"><a href="#图的逻辑结构和相关概念" class="headerlink" title="图的逻辑结构和相关概念"></a>图的逻辑结构和相关概念</h3><p>图G由顶点集V 和 边集E 组成，记为G=(V,E),(图不能为空)</p>
<p>其中V表示图G中顶点的有限非空集，E表示图G中顶点之间的边集合</p>
<p>|V|表示图G中顶点的个数，称为图G的阶，</p>
<p>|E|表示图G中边的条数</p>
<ul>
<li><p>无向图&amp;有向图</p>
</li>
<li><p>简单图：无重复边，不存在结点到自身的边</p>
<p>多重图：存在重复边，或存在结点到自身的边</p>
</li>
<li><p>完全图</p>
<ul>
<li>无向完全图 任意两个顶点之间都存在边</li>
<li>有向完全图 任意两个顶点之间都存在放心相反的弧</li>
</ul>
</li>
<li><p>子图</p>
<p>设有两个图G=(V,E)和G’=(V’,E’)，若V’是V的子集，且E’是E的子集，则称G’为G的子图</p>
</li>
<li><p>无向图：连通(V和W是连通的)</p>
<p>有向图：强连通(V到W，W到V)</p>
</li>
<li><p>连通图：任意两个结点之间都是连通的</p>
<p>强连通图：任意两个结点之间都是强连通的</p>
<ul>
<li>n个顶点的连通图(强连通图)最少有 n-1 条边</li>
</ul>
</li>
<li><p>连通分量 – 极大连通子图(不存在另一个子图能包含)</p>
<p>强连通分量 – 极大强连通子图</p>
</li>
<li><p>生成树：连通图包含全部顶点的一个极小连通子图</p>
<ul>
<li>n个顶点图的生成树有n-1条边</li>
</ul>
<p>生成森林： 非连通图所有连通分量的生成树组成生成森林</p>
</li>
<li><p>顶点的度：以该顶点为一个端点的边的数目</p>
<ul>
<li>无向图的度：以顶点V为端点的边的个数，记TD(V)</li>
<li>有向图的度：<ul>
<li>出度：以V为起点的有向边的条数，OD(V)</li>
<li>入度：以V为终点的有向边的条数,ID(V)</li>
</ul>
</li>
</ul>
</li>
<li><p>网：对边增加权重</p>
</li>
<li><p>稠密图：边多的图；  稀疏图：边少的图</p>
<ul>
<li>稀疏稠密的界定：|E|&lt;Vlog|V|  (边数小于顶点*顶点log值)</li>
</ul>
</li>
<li><p>有向树：一个顶点的入度为0、其余顶点的入度均为1的有向图</p>
</li>
<li><p>路径：</p>
</li>
<li><p>路径长度：路径上边的数目，若该路径最短则称其为距离</p>
</li>
<li><p>回路：第一个顶点和最后一个顶点相同的路径</p>
</li>
</ul>
<h3 id="图的存储结构及操作"><a href="#图的存储结构及操作" class="headerlink" title="图的存储结构及操作"></a>图的存储结构及操作</h3><h4 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h4><ul>
<li><p>结点数为n的图G = (V,E)的邻接矩阵A是n*n的</p>
<ul>
<li>有向图</li>
</ul>
<p><img src="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/D:%5Cblog%5Csource_posts%5Cimg%5C8.png" alt="8"></p>
<p>然后通过二维数组存放(权重)</p>
<ul>
<li>无向图–对称阵</li>
<li>无向图中第i行(或第i列)非0元素(非正无穷)的个数为第i个顶点的度</li>
<li>有向图中第i行(第i列)非0元素(非正无穷)的个数为第i个顶点的出度(入度)</li>
</ul>
</li>
<li><p>设图G的邻接矩阵为A，矩阵运算A的n次方 的含义</p>
<p>A的2次方 [2] [5]=2表示从顶点V2到顶点V5长度为2的路径有两条</p>
<ul>
<li>A的n次方[i] [j] 表示从顶点Vi到顶点Vj长度为n的路径有*条</li>
</ul>
</li>
</ul>
<h4 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h4><p>为每一个顶点建立一个单链表存放与它相邻的边</p>
<ul>
<li>顶点表： 采用顺序存储，每个数组元素存放顶点的数据和边表的头指针</li>
<li>边表(出边表)： 采用链式存储，单链表中存放与一个顶点相邻的所有边，一个链表结点表示一条从该顶点到链表结点顶点的边</li>
<li></li>
</ul>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/428591384.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/28859948.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o='孙欢'
        data-a='sunh-online'
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#绪论"><span class="toc-number">1.</span> <span class="toc-text">绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构基本概念"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构三要素"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构三要素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二章：线性表"><span class="toc-number">2.</span> <span class="toc-text">第二章：线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线性表的定义和基本操作"><span class="toc-number">2.1.</span> <span class="toc-text">线性表的定义和基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线性表的顺序表示"><span class="toc-number">2.2.</span> <span class="toc-text">线性表的顺序表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本操作："><span class="toc-number">2.2.1.</span> <span class="toc-text">基本操作：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线性表的链式表示"><span class="toc-number">2.3.</span> <span class="toc-text">线性表的链式表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单链表的基本操作"><span class="toc-number">2.3.1.</span> <span class="toc-text">单链表的基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双链表"><span class="toc-number">2.3.2.</span> <span class="toc-text">双链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序表与链表的比较"><span class="toc-number">2.4.</span> <span class="toc-text">顺序表与链表的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈和队列"><span class="toc-number">3.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#栈"><span class="toc-number">3.1.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列"><span class="toc-number">3.2.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈和队列的应用"><span class="toc-number">3.3.</span> <span class="toc-text">栈和队列的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#矩阵"><span class="toc-number">3.4.</span> <span class="toc-text">矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#串"><span class="toc-number">4.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#串-模式匹配"><span class="toc-number">4.1.</span> <span class="toc-text">串 模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KMP算法"><span class="toc-number">4.1.1.</span> <span class="toc-text">KMP算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树与二叉树"><span class="toc-number">5.</span> <span class="toc-text">树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树"><span class="toc-number">5.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#性质"><span class="toc-number">5.1.1.</span> <span class="toc-text">性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的顺序存储"><span class="toc-number">5.2.</span> <span class="toc-text">二叉树的顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的遍历"><span class="toc-number">5.3.</span> <span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线索二叉树"><span class="toc-number">5.4.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的存储结构"><span class="toc-number">5.5.</span> <span class="toc-text">树的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树、森林和二叉树的转换"><span class="toc-number">5.6.</span> <span class="toc-text">树、森林和二叉树的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的应用"><span class="toc-number">5.7.</span> <span class="toc-text">树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#并查集"><span class="toc-number">5.7.1.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉排序树"><span class="toc-number">5.7.2.</span> <span class="toc-text">二叉排序树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#平衡二叉树"><span class="toc-number">5.7.3.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈夫曼树"><span class="toc-number">5.7.4.</span> <span class="toc-text">哈夫曼树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图"><span class="toc-number">6.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图的逻辑结构和相关概念"><span class="toc-number">6.1.</span> <span class="toc-text">图的逻辑结构和相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图的存储结构及操作"><span class="toc-number">6.2.</span> <span class="toc-text">图的存储结构及操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#邻接矩阵法"><span class="toc-number">6.2.1.</span> <span class="toc-text">邻接矩阵法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#邻接表法"><span class="toc-number">6.2.2.</span> <span class="toc-text">邻接表法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图的遍历"><span class="toc-number">6.3.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#广度优先遍历"><span class="toc-number">6.3.1.</span> <span class="toc-text">广度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#深度优先遍历"><span class="toc-number">6.3.2.</span> <span class="toc-text">深度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图的应用"><span class="toc-number">6.4.</span> <span class="toc-text">图的应用</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
